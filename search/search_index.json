{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Go Commands","text":"<p>In Go, there are several built-in commands that you'll likely use frequently during development. These commands are part of the Go Tool suite, which helps with tasks like building, testing, and managing dependencies. Here\u2019s a list of the most commonly used Go commands:</p> <p>Learn More . . . GO Documentation</p>"},{"location":"#summary-of-most-common-commands","title":"Summary of Most Common Commands","text":"<ul> <li>Get Started: <code>go mod init &lt;project/module&gt;</code> for example: <code>go mod init example/hello</code></li> <li>Development: <code>go run</code>, <code>go build</code>, <code>go install</code></li> <li>Dependency Management: <code>go get</code>, <code>go mod tidy</code>, <code>go mod vendor</code></li> <li>Testing: <code>go test</code>, <code>go test -cover</code></li> <li>Formatting: <code>go fmt</code></li> <li>Documentation: <code>go doc</code></li> <li>Environment: <code>go version</code>, <code>go env</code></li> <li>Clean-up: <code>go clean</code></li> <li>Advanced: <code>go tool pprof</code>, <code>go generate</code></li> </ul>"},{"location":"#commands","title":"Commands","text":"<p>These are the core Go commands that you will use frequently to build, test, document, and manage dependencies for your Go applications.</p>"},{"location":"#1-go-run","title":"1. <code>go run</code>","text":"<ul> <li>Purpose: Compiles and runs Go source files.</li> <li>Usage:</li> </ul> <pre><code>go run main.go\n</code></pre> <ul> <li>Use case: When you want to quickly compile and execute a Go program without creating an executable.</li> </ul>"},{"location":"#2-go-build","title":"2. <code>go build</code>","text":"<ul> <li>Purpose: Compiles Go source code into an executable.</li> <li>Usage:</li> </ul> <pre><code>go build\n</code></pre> <p>To specify a filename:</p> <pre><code>go build -o output-file-name main.go\n</code></pre> <ul> <li>Use case: Compiling your Go program into a binary for deployment or testing.</li> </ul>"},{"location":"#3-go-install","title":"3. <code>go install</code>","text":"<ul> <li>Purpose: Compiles and installs the Go binary (places the executable in <code>$GOPATH/bin</code> or <code>$GOBIN</code>).</li> <li>Usage:</li> </ul> <pre><code>go install\n</code></pre> <ul> <li>Use case: Installs a compiled program to the Go workspace, making it available globally (useful for tools or utilities).</li> </ul>"},{"location":"#4-go-test","title":"4. <code>go test</code>","text":"<ul> <li>Purpose: Runs tests defined in the Go codebase.</li> <li>Usage:</li> </ul> <pre><code>go test\n</code></pre> <p>To run tests in a specific file:</p> <pre><code>go test -v ./...\n</code></pre> <p>For benchmarking:</p> <pre><code>go test -bench .\n</code></pre> <ul> <li>Use case: Running unit tests and benchmarks in your project.</li> </ul>"},{"location":"#5-go-fmt","title":"5. <code>go fmt</code>","text":"<ul> <li>Purpose: Automatically formats Go source code according to the Go standard style.</li> <li>Usage:</li> </ul> <pre><code>go fmt main.go\n</code></pre> <p>Or to format all Go files in the current directory and subdirectories:</p> <pre><code>go fmt ./...\n</code></pre> <ul> <li>Use case: Ensuring your code adheres to Go's formatting conventions.</li> </ul>"},{"location":"#6-go-get","title":"6. <code>go get</code>","text":"<ul> <li>Purpose: Downloads and installs dependencies from external repositories.</li> <li>Usage:</li> </ul> <pre><code>go get github.com/gin-gonic/gin\n</code></pre> <ul> <li>Use case: Installing external libraries or modules into your project\u2019s workspace.</li> </ul>"},{"location":"#7-go-mod","title":"7. <code>go mod</code>","text":"<ul> <li>Purpose: Manages dependencies for Go projects using Go Modules.</li> <li><code>go mod init</code> \u2014 Initializes a new Go module.</li> <li><code>go mod tidy</code> \u2014 Removes unused dependencies.</li> <li><code>go mod vendor</code> \u2014 Creates a <code>vendor</code> directory with dependencies.</li> <li><code>go mod verify</code> \u2014 Verifies that dependencies are consistent with <code>go.sum</code>.</li> <li>Usage:</li> </ul> <pre><code>go mod init\ngo mod tidy\ngo mod vendor\ngo mod verify\n</code></pre> <ul> <li>Use case: Managing project dependencies and ensuring version consistency.</li> </ul>"},{"location":"#8-go-doc","title":"8. <code>go doc</code>","text":"<ul> <li>Purpose: Displays documentation for Go packages or functions.</li> <li>Usage:</li> </ul> <pre><code>go doc fmt\ngo doc fmt.Println\n</code></pre> <ul> <li>Use case: Quickly checking documentation for standard or third-party packages.</li> </ul>"},{"location":"#9-go-clean","title":"9. <code>go clean</code>","text":"<ul> <li>Purpose: Removes build artifacts such as binaries, object files, and cached test results.</li> <li>Usage:</li> </ul> <pre><code>go clean\n</code></pre> <p>To clean specific files:</p> <pre><code>go clean -i\n</code></pre> <ul> <li>Use case: Cleaning up unnecessary files generated during the build or test process.</li> </ul>"},{"location":"#10-go-version","title":"10. <code>go version</code>","text":"<ul> <li>Purpose: Displays the current version of Go installed on your system.</li> <li>Usage:</li> </ul> <pre><code>go version\n</code></pre> <ul> <li>Use case: Checking the installed Go version.</li> </ul>"},{"location":"#11-go-env","title":"11. <code>go env</code>","text":"<ul> <li>Purpose: Displays Go environment variables.</li> <li>Usage:</li> </ul> <pre><code>go env\n</code></pre> <ul> <li>Use case: Viewing your Go environment settings, such as <code>GOPATH</code> and <code>GOBIN</code>.</li> </ul>"},{"location":"#12-go-list","title":"12. <code>go list</code>","text":"<ul> <li>Purpose: Lists Go packages and their dependencies.</li> <li>Usage:</li> </ul> <pre><code>go list ./...\n</code></pre> <ul> <li>Use case: Listing all the Go packages in your project or displaying metadata about a specific package.</li> </ul>"},{"location":"#13-go-mod-vendor","title":"13. <code>go mod vendor</code>","text":"<ul> <li>Purpose: Copies dependencies into a <code>vendor</code> directory, making them available locally.</li> <li>Usage:</li> </ul> <pre><code>go mod vendor\n</code></pre> <ul> <li>Use case: Managing dependencies within the <code>vendor</code> directory for applications that need it (e.g., in isolated environments or with certain deployment strategies).</li> </ul>"},{"location":"#14-go-doc-all","title":"14. <code>go doc -all</code>","text":"<ul> <li>Purpose: Shows all documentation available for all Go standard packages.</li> <li>Usage:</li> </ul> <pre><code>go doc -all\n</code></pre> <ul> <li>Use case: Quickly finding all the documentation for a particular module or package.</li> </ul>"},{"location":"#15-go-test-cover","title":"15. <code>go test -cover</code>","text":"<ul> <li>Purpose: Runs tests and displays test coverage.</li> <li>Usage:</li> </ul> <pre><code>go test -cover\n</code></pre> <ul> <li>Use case: Checking how much of your code is covered by tests.</li> </ul>"},{"location":"#16-go-generate","title":"16. <code>go generate</code>","text":"<ul> <li>Purpose: Runs code generators (usually used for generating code at compile-time based on annotations).</li> <li>Usage:</li> </ul> <pre><code>go generate\n</code></pre> <ul> <li>Use case: Executing code generation commands (like generating mock files or auto-generated code) before building the project.</li> </ul>"},{"location":"#17-go-tool-pprof","title":"17. <code>go tool pprof</code>","text":"<ul> <li>Purpose: Profiles and analyzes performance of Go programs.</li> <li>Usage:</li> </ul> <pre><code>go tool pprof &lt;binary&gt; &lt;profile&gt;\n</code></pre> <ul> <li>Use case: Analyzing the CPU or memory usage of a Go program.</li> </ul>"},{"location":"#18-go-run-with-multiple-files","title":"18. <code>go run</code> with multiple files","text":"<ul> <li>Purpose: You can also run multiple Go files together.</li> <li>Usage:</li> </ul> <pre><code>go run main.go utils.go\n</code></pre>"},{"location":"#19-go-install-for-global-tools","title":"19. <code>go install</code> for Global Tools","text":"<ul> <li>Purpose: Installs Go tools to <code>$GOPATH/bin</code> or <code>$GOBIN</code>.</li> <li>Usage:</li> </ul> <pre><code>go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n</code></pre> <ul> <li>Use case: Installing Go-based tools globally.</li> </ul>"},{"location":"#20-go-list-m","title":"20. <code>go list -m</code>","text":"<ul> <li>Purpose: Lists information about Go modules.</li> <li>Usage:</li> </ul> <pre><code>go list -m all\n</code></pre> <ul> <li>Use case: Displays module dependencies, useful when working with Go modules.</li> </ul>"},{"location":"datetime/","title":"DateTime Utility","text":"<p>The DateTime utility ensures that all timestamps are retrieved in UTC. UTC is the standard for timekeeping in distributed systems and avoids issues related to time zones or daylight saving time.</p>"},{"location":"datetime/#features","title":"Features","text":"<ul> <li>Retrieves the current time in UTC.</li> <li>Provides a straightforward implementation for consistent timekeeping.</li> <li>Easily integrates into other Go applications.</li> </ul>"},{"location":"datetime/#code","title":"Code","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\n// DateTimeUTC returns the current time in UTC.\nfunc DateTimeUTC() time.Time {\n    return time.Now().UTC()\n}\n\n// Main function demonstrating the use of DateTimeUTC.\nfunc main() {\n    fmt.Println(\"Current UTC Time:\", DateTimeUTC())\n}\n</code></pre>"},{"location":"datetime/#how-it-works","title":"How It Works","text":"<ol> <li> <p>UTC Time Retrieval:    The <code>DateTimeUTC</code> function calls <code>time.Now()</code> and applies <code>.UTC()</code> to convert the local system time to Coordinated Universal Time (UTC).</p> </li> <li> <p>Integration:    This function can be imported into any Go project to ensure uniform time representation.</p> </li> </ol>"},{"location":"datetime/#usage-example","title":"Usage Example","text":"<pre><code>$ go run main.go\nCurrent UTC Time: 2024-11-29 14:45:02.123456789 +0000 UTC\n</code></pre>"},{"location":"datetime/#best-practices","title":"Best Practices","text":"<ul> <li>Use UTC for Logging: UTC ensures that logs from different systems in various time zones are consistent and easy to correlate.</li> <li>Avoid Local Time: Avoid using <code>time.Now()</code> directly in distributed systems to prevent issues with time zone differences.</li> <li>Integrate into APIs: For APIs, always return timestamps in UTC to clients to avoid ambiguity.</li> </ul>"},{"location":"datetime/#further-reading","title":"Further Reading","text":"<ul> <li>Go's <code>time</code> Package Documentation</li> </ul> <p>This document is designed to ensure ease of use, clarity, and understanding for developers integrating the DateTime utility into their Go projects.</p>"},{"location":"docstring/","title":"Go <code>docstring</code>","text":"<p>The recommended approach in Go is to write the description in a docstring format, starting with a summary sentence on the first line, followed by more detailed explanations if needed. Here's an improved example with multi-line documentation:</p> <pre><code>package main\n\nimport \"fmt\"\n\n// MaxAttempts defines the maximum number of allowed connection retries.\n// This constant is used in scenarios where we need to ensure a limit\n// on the number of attempts to avoid infinite retries in case of failure.\n// It can be utilized in both client-side and server-side applications\n// for handling retry mechanisms.\nconst MaxAttempts = 5\n\n// User represents a basic user in the system. It includes an ID and Name,\n// which are the essential attributes to identify and greet a user.\n// This struct can be expanded to include more fields such as email,\n// role, or other relevant user information as required by the application.\ntype User struct {\n    ID   int    // User ID, a unique identifier for each user.\n    Name string // User's name, which is used in greeting messages.\n}\n\n// Greet prints a personalized greeting message for the user.\n// It accepts a User type as input and prints a formatted message\n// to the console. This function can be expanded to include more\n// complex greeting logic, such as time-based greetings (morning, evening),\n// or localization support for multiple languages.\nfunc Greet(user User) {\n    fmt.Printf(\"Hello, %s! Welcome to our service.\\n\", user.Name)\n}\n\n// CalculateSum computes the sum of two integers and returns the result.\n// It is a simple utility function that adds two numbers together.\n// This function can be used in scenarios where you need to perform basic\n// arithmetic operations, and it could be extended for more complex math\n// operations if necessary.\nfunc CalculateSum(a, b int) int {\n    return a + b\n}\n\nfunc main() {\n    // Example of using the User struct and Greet function.\n    user := User{ID: 1, Name: \"Alice\"}\n    Greet(user)\n\n    // Example of using the CalculateSum function.\n    sum := CalculateSum(10, 20)\n    fmt.Printf(\"Sum: %d\\n\", sum)\n}\n</code></pre>"},{"location":"docstring/#key-elements-of-multi-line-documentation","title":"Key Elements of Multi-line Documentation","text":"<ol> <li>Start with a brief summary on the first line. This will appear in GoDoc, so it should be succinct and give the reader an idea of what the constant, type, or function is doing.</li> <li> <p>Expand with further details if necessary. After the first line, you can add more information, such as context, limitations, or intended use cases for constants and functions.</p> </li> <li> <p>Be clear and concise: Avoid unnecessary verbosity, but do provide enough detail for the reader to understand how and when to use the constant, type, or function.</p> </li> </ol>"},{"location":"docstring/#notes","title":"Notes","text":"<ul> <li>GoDoc will automatically format these multi-line docstrings correctly, making it easy for developers to understand the code's purpose and usage directly from the documentation.</li> <li>For longer comments or when describing complex logic, always use a new line for each part of the explanation.</li> </ul>"},{"location":"for-loops/","title":"For Loop Blocks","text":"<p>In Go, the <code>for</code> loop is the only looping construct available. However, it is versatile enough to cover the functionality of <code>while</code> and <code>foreach</code> loops found in other languages. Below are examples to illustrate different ways you can use a <code>for</code> loop in Go:</p>"},{"location":"for-loops/#examples","title":"Examples","text":""},{"location":"for-loops/#1-basic-for-loop-like-pythons-for-i-in-rangen","title":"1. Basic <code>for</code> Loop (like Python's <code>for i in range(n)</code>)","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Loop from 0 to 4\n    for i := 0; i &lt; 5; i++ {\n        fmt.Println(\"Value of i:\", i)\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>i := 0</code> initializes the loop variable.</li> <li><code>i &lt; 5</code> is the condition to continue the loop.</li> <li><code>i++</code> increments <code>i</code> after each iteration.</li> </ul>"},{"location":"for-loops/#2-infinite-loop-like-pythons-while-true","title":"2. Infinite Loop (like Python's <code>while True</code>)","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    count := 0\n    for {\n        fmt.Println(\"Infinite loop iteration:\", count)\n        count++\n        if count &gt;= 5 { // Break the loop after 5 iterations\n            break\n        }\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The loop runs indefinitely unless you explicitly use <code>break</code> to exit.</li> </ul>"},{"location":"for-loops/#3-conditional-for-loop-like-pythons-while-loop","title":"3. Conditional <code>for</code> Loop (like Python's <code>while</code> loop)","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    count := 0\n    for count &lt; 5 { // Continue as long as count is less than 5\n        fmt.Println(\"Count is:\", count)\n        count++\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li>This behaves like a <code>while</code> loop in other languages.</li> </ul>"},{"location":"for-loops/#4-iterating-over-slicesarrays","title":"4. Iterating Over Slices/Arrays","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    numbers := []int{10, 20, 30, 40, 50}\n\n    // Using for loop with index\n    for i, num := range numbers {\n        fmt.Printf(\"Index: %d, Value: %d\\n\", i, num)\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>range</code> returns both the index and the value for each element in the slice.</li> <li>If you only need the value, use <code>_</code> to ignore the index.</li> </ul>"},{"location":"for-loops/#5-iterating-over-maps","title":"5. Iterating Over Maps","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    ages := map[string]int{\"Alice\": 25, \"Bob\": 30, \"Charlie\": 35}\n\n    for name, age := range ages {\n        fmt.Printf(\"%s is %d years old.\\n\", name, age)\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>range</code> works for maps and gives you the key-value pair.</li> </ul>"},{"location":"for-loops/#6-using-continue-and-break","title":"6. Using <code>continue</code> and <code>break</code>","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    for i := 0; i &lt; 10; i++ {\n        if i%2 == 0 {\n            continue // Skip even numbers\n        }\n        if i &gt; 7 {\n            break // Exit the loop if i &gt; 7\n        }\n        fmt.Println(\"Odd number:\", i)\n    }\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>continue</code> skips to the next iteration.</li> <li><code>break</code> exits the loop entirely.</li> </ul>"},{"location":"for-loops/#key-features","title":"Key Features","text":"<ul> <li>Initialization and Increment: Can be omitted (e.g., <code>for ; i &lt; 5; ;</code>).</li> <li>Infinite Loops: Use <code>for</code> without conditions.</li> <li>Iterating Collections: Use <code>range</code>.</li> </ul> <p>With these variations, Go's <code>for</code> loop is both simple and powerful.</p>"},{"location":"if-blocks/","title":"IF Statement Blocks","text":"<p>In Go, the <code>if</code> statement is similar to other programming languages. It allows you to execute a block of code based on a condition. Here's a detailed guide with examples:</p>"},{"location":"if-blocks/#examples","title":"Examples","text":""},{"location":"if-blocks/#basic-syntax","title":"Basic Syntax","text":"<pre><code>if condition {\n    // Code to execute if condition is true\n}\n</code></pre>"},{"location":"if-blocks/#example-1-basic-if-statement","title":"Example 1: Basic <code>if</code> Statement","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 10\n\n    if x &gt; 5 {\n        fmt.Println(\"x is greater than 5\")\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>x is greater than 5\n</code></pre>"},{"location":"if-blocks/#example-2-if-else-statement","title":"Example 2: <code>if-else</code> Statement","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 3\n\n    if x &gt; 5 {\n        fmt.Println(\"x is greater than 5\")\n    } else {\n        fmt.Println(\"x is 5 or less\")\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>x is 5 or less\n</code></pre>"},{"location":"if-blocks/#example-3-if-else-if-else-statement","title":"Example 3: <code>if-else if-else</code> Statement","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 7\n\n    if x &gt; 10 {\n        fmt.Println(\"x is greater than 10\")\n    } else if x &gt; 5 {\n        fmt.Println(\"x is greater than 5 but less than or equal to 10\")\n    } else {\n        fmt.Println(\"x is 5 or less\")\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>x is greater than 5 but less than or equal to 10\n</code></pre>"},{"location":"if-blocks/#example-4-short-variable-declaration-in-if","title":"Example 4: Short Variable Declaration in <code>if</code>","text":"<p>You can declare and initialize a variable directly within the <code>if</code> statement, and its scope is limited to that block.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    if y := 15; y &gt; 10 { // Declare and initialize y in the if statement\n        fmt.Println(\"y is greater than 10\")\n    }\n    // fmt.Println(y) // Error: y is not defined here\n}\n</code></pre> <p>Output:</p> <pre><code>y is greater than 10\n</code></pre>"},{"location":"if-blocks/#example-5-checking-multiple-conditions","title":"Example 5: Checking Multiple Conditions","text":"<p>Use logical operators (<code>&amp;&amp;</code>, <code>||</code>) to combine conditions.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 8\n\n    if x &gt; 5 &amp;&amp; x &lt; 10 {\n        fmt.Println(\"x is between 5 and 10\")\n    }\n\n    if x &lt; 5 || x &gt; 10 {\n        fmt.Println(\"x is not between 5 and 10\")\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>x is between 5 and 10\n</code></pre>"},{"location":"if-blocks/#example-6-comparing-strings","title":"Example 6: Comparing Strings","text":"<p>You can compare strings lexicographically using <code>if</code>.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    name := \"Alice\"\n\n    if name == \"Alice\" {\n        fmt.Println(\"Hello, Alice!\")\n    } else {\n        fmt.Println(\"You're not Alice!\")\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>Hello, Alice!\n</code></pre>"},{"location":"if-blocks/#key-notes","title":"Key Notes","text":"<ol> <li>Braces are mandatory: Unlike some languages (e.g., Python), Go requires braces <code>{}</code> for <code>if</code> blocks, even for a single statement.</li> <li>No parentheses: Parentheses around the condition are optional but discouraged (<code>if (x &gt; 5)</code> is valid, but idiomatic Go uses <code>if x &gt; 5</code>).</li> <li>Short variable declaration: Variables declared in <code>if</code> (e.g., <code>y := 15</code>) are scoped to the <code>if</code> block and its associated <code>else</code> or <code>else if</code> blocks.</li> </ol>"},{"location":"if-blocks/#common-mistakes","title":"Common Mistakes","text":"<ul> <li>Forgetting braces <code>{}</code>.</li> <li>Trying to use variables declared in the <code>if</code> statement outside its scope.</li> <li>Misusing logical operators (<code>&amp;&amp;</code>, <code>||</code>).</li> </ul> <p>With these examples and tips, you should be able to use <code>if</code> effectively in Go!</p>"},{"location":"naming_conventions/","title":"Naming Conventions","text":"<p>In Go, naming conventions are consistent and idiomatic, helping to make code readable and maintainable. Here's an overview of the recommended naming conventions in Go:</p>"},{"location":"naming_conventions/#summary-table","title":"Summary Table","text":"Element Convention Example Files <code>snake_case</code> <code>user_service.go</code> Packages <code>lowercase</code> <code>http</code>, <code>json</code> Functions <code>camelCase</code> <code>getUserName</code>, <code>update</code> Variables <code>camelCase</code> <code>userName</code>, <code>maxRetries</code> Exported Funcs <code>PascalCase</code> <code>GetUserName</code> Constants <code>PascalCase</code> <code>MaxConnections</code> Structs <code>PascalCase</code> <code>User</code>, <code>Product</code> Interfaces <code>PascalCase</code> <code>Reader</code>, <code>Logger</code>"},{"location":"naming_conventions/#additional-notes","title":"Additional Notes","text":"<ol> <li>Exporting Symbols: If something starts with an uppercase letter, it becomes exported and accessible outside the package.</li> <li>Keep It Short: Go values simplicity, so avoid verbose names.</li> <li>Acronyms: Use consistent casing for acronyms like <code>HTTP</code>, <code>URL</code>, <code>ID</code>.</li> <li>Example: <code>HTTPRequest</code>, <code>userID</code>.</li> </ol> <p>By following these conventions, your Go code will remain idiomatic and align well with community standards.</p>"},{"location":"naming_conventions/#examples","title":"Examples","text":""},{"location":"naming_conventions/#1-functions-and-methods","title":"1. Functions and Methods","text":"<ul> <li>Use camelCase for function and method names.</li> <li>Exported functions/methods (those that are accessible outside the package) must start with an uppercase letter (PascalCase).</li> <li>Non-exported functions/methods (internal to the package) start with a lowercase letter (camelCase).</li> </ul>"},{"location":"naming_conventions/#example","title":"Example","text":"<pre><code>// Exported function (visible outside the package)\nfunc GetUserName() string {\n    return \"John Doe\"\n}\n\n// Non-exported function (only accessible within the package)\nfunc calculateSum(a, b int) int {\n    return a + b\n}\n</code></pre>"},{"location":"naming_conventions/#2-variables-and-constants","title":"2. Variables and Constants","text":"<ul> <li>Use camelCase for variables.</li> <li>Use ALL_CAPS_WITH_UNDERSCORES or PascalCase for constants, though PascalCase is more common in Go.</li> </ul>"},{"location":"naming_conventions/#example_1","title":"Example","text":"<pre><code>// Variables\nvar userName string\nvar maxRetries int\n\n// Constants\nconst MaxConnections = 10\nconst DefaultTimeout = 30\n</code></pre>"},{"location":"naming_conventions/#3-structs","title":"3. Structs","text":"<ul> <li>Use PascalCase for struct names (always exported by convention).</li> </ul>"},{"location":"naming_conventions/#example_2","title":"Example","text":"<pre><code>type User struct {\n    ID   int\n    Name string\n}\n</code></pre>"},{"location":"naming_conventions/#4-interfaces","title":"4. Interfaces","text":"<ul> <li>Use PascalCase for interface names.</li> <li>Interface names should describe behavior and often end in -er (e.g., <code>Reader</code>, <code>Writer</code>, <code>Logger</code>) or have a descriptive name like <code>Database</code>.</li> </ul>"},{"location":"naming_conventions/#example_3","title":"Example","text":"<pre><code>type Reader interface {\n    Read(data []byte) (int, error)\n}\n</code></pre>"},{"location":"naming_conventions/#5-packages","title":"5. Packages","text":"<ul> <li>Use lowercase letters for package names.</li> <li>Avoid underscores, hyphens, or mixed case.</li> <li>Package names should be short and describe their functionality.</li> </ul>"},{"location":"naming_conventions/#example_4","title":"Example","text":"<pre><code>math, strings, http, json\n</code></pre> <p>When importing:</p> <pre><code>import \"github.com/username/awesome_module/package_one\"\n</code></pre>"},{"location":"naming_conventions/#6-files","title":"6. Files","text":"<ul> <li>Use snake_case for file names.</li> <li>File names should reflect the contents or primary functionality.</li> </ul>"},{"location":"naming_conventions/#example_5","title":"Example","text":"<pre><code>user_service.go\ndatabase_connection.go\nhttp_handler.go\n</code></pre>"},{"location":"naming_conventions/#7-test-functions","title":"7. Test Functions","text":"<ul> <li>Test functions should start with <code>Test</code> followed by a descriptive name in PascalCase.</li> <li>Benchmarks and examples follow similar conventions.</li> </ul>"},{"location":"naming_conventions/#example_6","title":"Example","text":"<pre><code>func TestCalculateSum(t *testing.T) {\n    result := calculateSum(2, 3)\n    if result != 5 {\n        t.Errorf(\"Expected 5, got %d\", result)\n    }\n}\n</code></pre>"},{"location":"strings/","title":"Strings","text":"<p>The <code>fmt.Sprintf</code> function in Go is part of the <code>fmt</code> package and is used to format strings. Unlike <code>fmt.Printf</code>, which prints the formatted string directly to standard output, <code>fmt.Sprintf</code> returns the formatted string, allowing you to assign it to variables or use it in further operations.</p>"},{"location":"strings/#basic-syntax","title":"Basic Syntax","text":"<pre><code>func Sprintf(format string, a ...interface{}) string\n</code></pre> <ul> <li><code>format</code>: A string containing format specifiers (placeholders) that define how the provided values should be formatted.</li> <li><code>a</code>: A variadic parameter for the values to be formatted and substituted into the <code>format</code> string.</li> </ul>"},{"location":"strings/#common-format-specifiers","title":"Common Format Specifiers","text":"<ol> <li> <p>General Specifiers:</p> </li> <li> <p><code>%v</code>: Default format for any value.</p> </li> <li><code>%+v</code>: Includes field names for structs.</li> <li><code>%#v</code>: Go syntax representation of the value.</li> <li> <p><code>%T</code>: Type of the value.</p> </li> <li> <p>Integer Formatting:</p> </li> <li> <p><code>%d</code>: Decimal (base 10).</p> </li> <li><code>%b</code>: Binary (base 2).</li> <li><code>%o</code>: Octal (base 8).</li> <li><code>%x</code>: Hexadecimal (base 16, lowercase).</li> <li> <p><code>%X</code>: Hexadecimal (base 16, uppercase).</p> </li> <li> <p>Floating-Point and Complex Numbers:</p> </li> <li> <p><code>%f</code>: Decimal point (e.g., 123.456).</p> </li> <li><code>%e</code>: Scientific notation (lowercase, e.g., 1.234560e+02).</li> <li><code>%E</code>: Scientific notation (uppercase, e.g., 1.234560E+02).</li> <li> <p><code>%.nf</code>: Specify precision to <code>n</code> decimal places.</p> </li> <li> <p>Strings and Characters:</p> </li> <li> <p><code>%s</code>: String.</p> </li> <li><code>%q</code>: Quoted string with escape characters.</li> <li><code>%c</code>: Unicode character.</li> <li> <p><code>%U</code>: Unicode code point (e.g., <code>U+1234</code>).</p> </li> <li> <p>Booleans:</p> </li> <li> <p><code>%t</code>: Prints <code>true</code> or <code>false</code>.</p> </li> <li> <p>Pointer Addresses:</p> </li> <li><code>%p</code>: Pointer address.</li> </ol>"},{"location":"strings/#examples","title":"Examples","text":""},{"location":"strings/#basic-formatting","title":"Basic Formatting","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    name := \"Alice\"\n    age := 30\n\n    result := fmt.Sprintf(\"Name: %s, Age: %d\", name, age)\n    fmt.Println(result) // Output: Name: Alice, Age: 30\n}\n</code></pre>"},{"location":"strings/#using-structs","title":"Using Structs","text":"<pre><code>package main\n\nimport \"fmt\"\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    p := Person{\"Bob\", 25}\n\n    result := fmt.Sprintf(\"Struct: %v\", p)\n    fmt.Println(result) // Output: Struct: {Bob 25}\n\n    resultWithFields := fmt.Sprintf(\"Struct with fields: %+v\", p)\n    fmt.Println(resultWithFields) // Output: Struct with fields: {Name:Bob Age:25}\n\n    goSyntax := fmt.Sprintf(\"Go syntax: %#v\", p)\n    fmt.Println(goSyntax) // Output: Go syntax: main.Person{Name:\"Bob\", Age:25}\n}\n</code></pre>"},{"location":"strings/#formatting-numbers","title":"Formatting Numbers","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    num := 255\n\n    binary := fmt.Sprintf(\"Binary: %b\", num)\n    fmt.Println(binary) // Output: Binary: 11111111\n\n    octal := fmt.Sprintf(\"Octal: %o\", num)\n    fmt.Println(octal) // Output: Octal: 377\n\n    hex := fmt.Sprintf(\"Hexadecimal: %x\", num)\n    fmt.Println(hex) // Output: Hexadecimal: ff\n\n    upperHex := fmt.Sprintf(\"Uppercase Hex: %X\", num)\n    fmt.Println(upperHex) // Output: Uppercase Hex: FF\n}\n</code></pre>"},{"location":"strings/#floating-point-precision","title":"Floating-Point Precision","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    pi := 3.14159265359\n\n    result := fmt.Sprintf(\"Pi (default): %f\", pi)\n    fmt.Println(result) // Output: Pi (default): 3.141593\n\n    resultPrecision := fmt.Sprintf(\"Pi (2 decimal places): %.2f\", pi)\n    fmt.Println(resultPrecision) // Output: Pi (2 decimal places): 3.14\n}\n</code></pre>"},{"location":"strings/#combining-multiple-types","title":"Combining Multiple Types","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    name := \"Eve\"\n    isStudent := true\n    grade := 89.5\n\n    result := fmt.Sprintf(\"Name: %s, Student: %t, Grade: %.1f\", name, isStudent, grade)\n    fmt.Println(result) // Output: Name: Eve, Student: true, Grade: 89.5\n}\n</code></pre>"},{"location":"strings/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ol> <li>Readability: Use meaningful format specifiers to enhance the readability of your code.</li> <li>Escaping <code>%</code>: To include a literal <code>%</code> in the output, use <code>%%</code>.</li> </ol> <pre><code>fmt.Sprintf(\"Percentage: 50%%\") // Output: Percentage: 50%\n</code></pre> <ol> <li>Error Logging: Combine <code>Sprintf</code> with error handling to create informative error messages.</li> </ol> <pre><code>errMsg := fmt.Sprintf(\"Error: Unable to find user with ID %d\", userID)\nlog.Println(errMsg)\n</code></pre> <ol> <li>Debugging: Use <code>%#v</code> to inspect complex objects during debugging.</li> </ol> <p>With <code>fmt.Sprintf</code>, you have a versatile tool for formatting strings dynamically in Go. It is widely used for logging, error handling, and constructing strings for user-facing outputs.</p>"},{"location":"types/","title":"Types","text":"<p>Go has a set of built-in types that are divided into basic types, composite types, and more advanced system types. Here's an overview:</p>"},{"location":"types/#1-basic-types","title":"1. Basic Types","text":"<p>These are the fundamental data types in Go:</p> Category Type Description Example Boolean <code>bool</code> Represents true/false values. <code>true</code>, <code>false</code> Integer <code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> Signed integers of various sizes. <code>42</code>, <code>-128</code> Unsigned Int <code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code> Unsigned integers (non-negative). <code>0</code>, <code>255</code> Alias Int <code>byte</code> Alias for <code>uint8</code>, typically for raw binary data. <code>255</code> Alias Int <code>rune</code> Alias for <code>int32</code>, used for Unicode code points. <code>'A'</code>, <code>'\\u4F60'</code> Floating Point <code>float32</code>, <code>float64</code> Floating-point numbers for decimals. <code>3.14</code>, <code>1.618</code> Complex <code>complex64</code>, <code>complex128</code> Complex numbers with real and imaginary parts. <code>1 + 2i</code> String <code>string</code> Immutable sequences of bytes representing text. <code>\"Hello, World!\"</code>"},{"location":"types/#2-composite-types","title":"2. Composite Types","text":"<p>These are types that combine other types:</p> Type Description Example Array Fixed-length sequence of elements of the same type. <code>var a [5]int = [5]int{1, 2, 3, 4, 5}</code> Slice Dynamic-length array abstraction. <code>var s []int = []int{1, 2, 3}</code> Map Key-value pair collection. <code>var m map[string]int = map[string]int{\"a\": 1}</code> Struct Collection of named fields of various types. <code>type Point struct { X, Y int }</code> Pointer Reference to a memory address of a variable. <code>var p *int = &amp;x</code> Function First-class functions with optional return values. <code>func add(a, b int) int { return a + b }</code> Channel Communication mechanism for goroutines. <code>ch := make(chan int)</code> Interface Defines a set of method signatures. <code>type Reader interface { Read(p []byte) }</code>"},{"location":"types/#3-system-types","title":"3. System Types","text":"<p>These types relate to more advanced operations and system-level functionality:</p> Type Description Example uintptr An integer large enough to hold a pointer. Used for low-level programming. unsafe.Pointer Allows converting between different pointer types. Requires <code>unsafe</code> package."},{"location":"types/#4-alias-and-special-types","title":"4. Alias and Special Types","text":"<p>These types are aliases for specific use cases:</p> Type Alias For Description Example <code>byte</code> <code>uint8</code> Used for raw data or bytes. <code>'A'</code> <code>rune</code> <code>int32</code> Used for Unicode code points. <code>'\ud83d\ude0a'</code>"},{"location":"types/#5-constants-and-their-types","title":"5. Constants and Their Types","text":"<p>Constants in Go have specific types, including:</p> Category Example Untyped constants <code>const Pi = 3.14</code> Typed constants <code>const Pi float64 = 3.14</code>"},{"location":"types/#6-example-code-using-built-in-types","title":"6. Example Code Using Built-in Types","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Basic types\n    var age int = 25\n    var price float64 = 19.99\n    var active bool = true\n    var name string = \"Alice\"\n\n    // Composite types\n    var numbers = []int{1, 2, 3} // Slice\n    var grades = map[string]int{\"math\": 95, \"science\": 90} // Map\n\n    // Struct\n    type Point struct {\n        X int\n        Y int\n    }\n    var p = Point{X: 10, Y: 20}\n\n    // Print values\n    fmt.Println(age, price, active, name)\n    fmt.Println(numbers, grades)\n    fmt.Println(p)\n}\n</code></pre>"},{"location":"types/#type-summary","title":"Type Summary","text":"<p>Go's type system is simple yet powerful, combining built-in types for primitive operations with composite types for complex data structures. These types ensure both performance and clarity in code.</p>"},{"location":"union-any/","title":"Union | Any","text":"<p>Go does not have a built-in union type as in languages like C or Rust. However, Go provides alternatives for achieving similar functionality through interfaces and type switches. Here are some common patterns:</p>"},{"location":"union-any/#examples","title":"Examples","text":""},{"location":"union-any/#1-using-interface-as-a-union-type","title":"1. Using <code>interface{}</code> as a Union Type","text":"<p>In Go, the empty interface (<code>interface{}</code>) can hold any value, effectively serving as a union of all types. However, you'll need to assert or check the type at runtime.</p> <pre><code>package main\n\nimport \"fmt\"\n\n// Example function that accepts a union of types\nfunc processValue(value interface{}) {\n    switch v := value.(type) {\n    case int:\n        fmt.Printf(\"Integer: %d\\n\", v)\n    case string:\n        fmt.Printf(\"String: %s\\n\", v)\n    case bool:\n        fmt.Printf(\"Boolean: %v\\n\", v)\n    default:\n        fmt.Println(\"Unknown type\")\n    }\n}\n\nfunc main() {\n    processValue(42)       // Integer\n    processValue(\"hello\")  // String\n    processValue(true)     // Boolean\n}\n</code></pre> <p>Explanation:</p> <ul> <li>The <code>interface{}</code> type allows holding any value.</li> <li>Use a type switch (<code>value.(type)</code>) to handle different types explicitly.</li> </ul>"},{"location":"union-any/#2-using-structs-with-tagged-fields","title":"2. Using Structs with Tagged Fields","text":"<p>You can create a struct with fields for different possible types and use one field at a time.</p> <pre><code>package main\n\nimport \"fmt\"\n\n// Union type using a struct\ntype Value struct {\n    IntVal   *int\n    StringVal *string\n    BoolVal  *bool\n}\n\nfunc processValue(value Value) {\n    if value.IntVal != nil {\n        fmt.Printf(\"Integer: %d\\n\", *value.IntVal)\n    } else if value.StringVal != nil {\n        fmt.Printf(\"String: %s\\n\", *value.StringVal)\n    } else if value.BoolVal != nil {\n        fmt.Printf(\"Boolean: %v\\n\", *value.BoolVal)\n    } else {\n        fmt.Println(\"No value\")\n    }\n}\n\nfunc main() {\n    intValue := 42\n    strValue := \"hello\"\n    boolValue := true\n\n    processValue(Value{IntVal: &amp;intValue})\n    processValue(Value{StringVal: &amp;strValue})\n    processValue(Value{BoolVal: &amp;boolValue})\n}\n</code></pre> <p>Explanation:</p> <ul> <li>A struct acts as a tagged union where only one field is used at a time.</li> <li>Use <code>nil</code> to indicate which field is active.</li> </ul>"},{"location":"union-any/#3-using-generics-go-118","title":"3. Using Generics (Go 1.18+)","text":"<p>If you're working with Go 1.18 or later, you can use generics for type-safe unions by defining constraints.</p> <pre><code>package main\n\nimport \"fmt\"\n\n// Define a generic constraint\ntype Union interface {\n    int | string | bool\n}\n\nfunc processValue[T Union](value T) {\n    fmt.Printf(\"Value: %v (Type: %T)\\n\", value, value)\n}\n\nfunc main() {\n    processValue(42)       // Integer\n    processValue(\"hello\")  // String\n    processValue(true)     // Boolean\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>Union</code> defines a constraint for accepted types (<code>int | string | bool</code>).</li> <li>The function <code>processValue</code> is generic and works with any type that satisfies the constraint.</li> </ul>"},{"location":"union-any/#comparison-of-approaches","title":"Comparison of Approaches","text":"Approach Advantages Limitations <code>interface{}</code> Flexible, works with any type Type-checking only at runtime Tagged Struct Clear type usage Verbose, requires manual handling Generics (Go 1.18+) Type-safe, compile-time checks Limited to supported Go versions"},{"location":"union-any/#best-practices","title":"Best Practices","text":"<ul> <li>Use <code>interface{}</code> or tagged structs for older Go versions or when flexibility is paramount.</li> <li>Use generics for type-safe union types in Go 1.18+ when the union is well-defined.</li> </ul>"},{"location":"variables/","title":"Variables","text":""},{"location":"variables/#description","title":"Description","text":"<p>In Go, <code>=</code> and <code>:=</code> are both used for assignment, but they serve different purposes depending on the context. Here's a breakdown of when to use each:</p>"},{"location":"variables/#short-variable-declaration","title":"<code>:=</code> (Short Variable Declaration)","text":"<p>Use <code>:=</code> when declaring and initializing a variable at the same time. This is typically used within functions.</p>"},{"location":"variables/#key-points","title":"Key Points","text":"<ul> <li>Can only be used inside a function (not at the package level).</li> <li>Automatically determines the variable's type based on the value assigned.</li> <li>Declares and assigns the variable in a single step.</li> </ul>"},{"location":"variables/#example","title":"Example","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Using := to declare and initialize a variable\n    x := 10        // x is an int\n    message := \"Hi\" // message is a string\n\n    fmt.Println(x, message)\n}\n</code></pre>"},{"location":"variables/#assignment-operator","title":"<code>=</code> (Assignment Operator)","text":"<p>Use <code>=</code> when assigning a value to an already declared variable or when explicitly declaring variables with the <code>var</code> keyword.</p>"},{"location":"variables/#key-points_1","title":"Key Points","text":"<ul> <li>Can be used anywhere, including at the package level.</li> <li>Does not declare the variable (requires it to already exist).</li> <li>Used for reassigning values to existing variables.</li> </ul>"},{"location":"variables/#example_1","title":"Example","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var x int         // Declare variable x\n    x = 20            // Assign a value to x\n\n    var message string\n    message = \"Hello\" // Assign a value to message\n\n    fmt.Println(x, message)\n}\n</code></pre>"},{"location":"variables/#when-to-use-each","title":"When to Use Each","text":"Scenario Use <code>:=</code> Use <code>=</code> Declaring and initializing a variable \u2705 \u274c Reassigning a value to an existing variable \u274c \u2705 Declaring at the package level \u274c (not allowed) \u2705 (with <code>var</code> or <code>const</code>) Inside a function \u2705 (for new variables) \u2705 (for already declared vars)"},{"location":"variables/#example-combined-use","title":"Example: Combined Use","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 10       // Declare and initialize x\n    fmt.Println(x) // Prints 10\n\n    x = 20        // Reassign a new value to x\n    fmt.Println(x) // Prints 20\n\n    y := 30       // Declare and initialize y\n    fmt.Println(y) // Prints 30\n\n    y = x + 10    // Reassign y using x\n    fmt.Println(y) // Prints 30\n}\n</code></pre>"},{"location":"variables/#pitfalls-with","title":"Pitfalls with <code>:=</code>","text":"<ol> <li>Shadowing: Using <code>:=</code> can accidentally declare a new variable instead of updating an existing one.</li> </ol> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 10\n    if true {\n        x := 20 // This creates a new variable shadowing the outer x\n        fmt.Println(x) // Prints 20 (inner x)\n    }\n    fmt.Println(x) // Prints 10 (outer x)\n}\n</code></pre> <p>To avoid this, use <code>=</code> when modifying an existing variable.</p> <ol> <li>Cannot Use at the Package Level:</li> </ol> <pre><code>// This will not compile:\nx := 10 // Error: short variable declaration not allowed at package level\n</code></pre>"},{"location":"variables/#best-practices","title":"Best Practices","text":"<ul> <li>Use <code>:=</code> for new variables when you're writing concise code inside functions.</li> <li>Use <code>=</code> when updating variables or declaring them explicitly with <code>var</code>.</li> <li>Avoid shadowing by carefully managing <code>:=</code> within nested scopes.</li> </ul>"},{"location":"advanced/cli/","title":"Command-Line Interface","text":"<p>If you're looking for a Go solution similar to Python's <code>argparse</code> for handling command-line arguments, Go has several libraries that help with parsing and handling command-line arguments. The standard <code>flag</code> package provides basic functionality, but if you're looking for something closer to <code>argparse</code> with more features like subcommands, argument types, and default values, libraries like <code>cobra</code> and <code>kingpin</code> are good options.</p>"},{"location":"advanced/cli/#examples","title":"Examples","text":""},{"location":"advanced/cli/#1-using-the-go-standard-library-flag","title":"1. Using the Go Standard Library: <code>flag</code>","text":"<p>Go\u2019s built-in <code>flag</code> package is simple and provides basic functionality for parsing command-line flags. It\u2019s a good starting point for simple scripts.</p>"},{"location":"advanced/cli/#example-using-flag","title":"Example Using <code>flag</code>","text":"<pre><code>package main\n\nimport (\n \"flag\"\n \"fmt\"\n)\n\nfunc main() {\n // Define flags\n name := flag.String(\"name\", \"World\", \"Name to greet\")\n age := flag.Int(\"age\", 0, \"Your age\")\n help := flag.Bool(\"help\", false, \"Show Help\")\n\n // Parse the command-line flags\n flag.Parse()\n\n // Use the parsed flags\n if *help {\n  fmt.Printf(\"Help: %v\", *help)\n } else {\n  fmt.Printf(\"Hello, %s!\\n\", *name)\n  fmt.Printf(\"You are %d years old.\\n\", *age)\n }\n}\n</code></pre> <p>Usage:</p> <pre><code>go run main.go --name John --age 30\n</code></pre> <p>This would output:</p> <pre><code>Hello, John!\nYou are 30 years old.\n</code></pre>"},{"location":"advanced/cli/#2-using-cobra-for-more-advanced-features","title":"2. Using <code>cobra</code> for More Advanced Features","text":"<p><code>cobra</code> is a more feature-rich library for building command-line applications in Go. It supports commands, subcommands, argument parsing, flags, and more. It\u2019s a great choice for building applications similar to Python's <code>argparse</code>.</p>"},{"location":"advanced/cli/#example-using-cobra","title":"Example Using <code>cobra</code>","text":"<pre><code>package main\n\nimport (\n \"fmt\"\n \"github.com/spf13/cobra\"\n)\n\nfunc main() {\n var name string\n var age int\n\n // Define the root command\n var rootCmd = &amp;cobra.Command{\n  Use:   \"greet\",\n  Short: \"A simple greeting app\",\n  Run: func(cmd *cobra.Command, args []string) {\n   fmt.Printf(\"Hello, %s! You are %d years old.\\n\", name, age)\n  },\n }\n\n // Define flags for the root command\n rootCmd.Flags().StringVarP(&amp;name, \"name\", \"n\", \"World\", \"Name to greet\")\n rootCmd.Flags().IntVarP(&amp;age, \"age\", \"a\", 0, \"Age of the person\")\n\n // Execute the root command\n if err := rootCmd.Execute(); err != nil {\n  fmt.Println(err)\n }\n}\n</code></pre> <p>Usage:</p> <pre><code>go run main.go greet -n John -a 30\n</code></pre> <p>This would output:</p> <pre><code>Hello, John! You are 30 years old.\n</code></pre>"},{"location":"advanced/cli/#3-go-osexec-for-running-other-scripts","title":"3. Go + <code>os/exec</code> for Running Other Scripts","text":"<p>Go can execute external scripts and commands using the <code>os/exec</code> package. This allows you to run shell scripts, Python scripts, or other programs from within your Go program.</p>"},{"location":"advanced/cli/#example-running-a-shell-script-from-go","title":"Example: Running a Shell Script from Go","text":"<pre><code>package main\n\nimport (\n \"fmt\"\n \"os/exec\"\n)\n\nfunc main() {\n // Run a shell command (in this case, a simple \"ls\" command)\n cmd := exec.Command(\"ls\", \"-l\")\n output, err := cmd.CombinedOutput()\n if err != nil {\n  fmt.Println(\"Error executing command:\", err)\n  return\n }\n\n // Print the output of the command\n fmt.Println(string(output))\n}\n</code></pre>"},{"location":"advanced/cli/#conclusion","title":"Conclusion","text":"<p>For Go scripting similar to Python's <code>argparse</code>, you can:</p> <ol> <li>Use Go\u2019s built-in <code>flag</code> package for basic flag parsing.</li> <li>Use <code>cobra</code> for advanced features, including subcommands and dynamic argument parsing.</li> <li>Use <code>os/exec</code>: To run external scripts or commands.</li> </ol>"},{"location":"advanced/pointers/","title":"Using the (<code>*Pointer</code> or <code>Value</code>)","text":"<p>In Go, the <code>&amp;</code> operator is used to get the address of a variable. When it comes to types, using <code>&amp;</code> with a type generally appears in the context of initializing or passing pointers to types. Here are the common scenarios where <code>&amp;</code> is used:</p>"},{"location":"advanced/pointers/#1-using-accesscontrol-pointer-receiver","title":"1. Using <code>*AccessControl</code> (Pointer Receiver)","text":""},{"location":"advanced/pointers/#code-1","title":"Code 1","text":"<pre><code>func (ac *AccessControl) SetRules(rules Rules) *AccessControl {\n ac.Rules = rules\n return ac\n}\n</code></pre>"},{"location":"advanced/pointers/#when-to-use-1","title":"When to Use 1","text":"<ol> <li> <p>Modifying the Receiver's State:</p> </li> <li> <p>Use a pointer receiver when the method modifies the state of the struct it operates on.</p> </li> <li> <p>In this case, <code>ac.Rules = rules</code> directly updates the <code>Rules</code> field of the original <code>AccessControl</code> instance.</p> </li> <li> <p>Avoiding Copying Large Structures:</p> </li> <li> <p>If the <code>AccessControl</code> struct is large, passing it by pointer avoids the overhead of copying it for each method call.</p> </li> <li> <p>Chainable Methods:</p> </li> <li> <p>Returning a pointer (<code>*AccessControl</code>) allows for method chaining:</p> <pre><code>ac.SetRules(rules).AnotherMethod()\n</code></pre> </li> </ol>"},{"location":"advanced/pointers/#2-using-accesscontrol-value-receiver","title":"2. Using <code>AccessControl</code> (Value Receiver)","text":""},{"location":"advanced/pointers/#code-2","title":"Code 2","text":"<pre><code>func (ac AccessControl) SetRules(rules Rules) AccessControl {\n ac.Rules = rules\n return ac\n}\n</code></pre>"},{"location":"advanced/pointers/#when-to-use-2","title":"When to Use 2","text":"<ol> <li> <p>Immutable Operations:</p> </li> <li> <p>Use a value receiver if the method doesn't need to modify the receiver's state.</p> </li> <li> <p>The <code>ac.Rules = rules</code> change affects only a copy of the struct and doesn't alter the original instance.</p> </li> <li> <p>Small Structs:</p> </li> <li> <p>If the struct is small, passing by value is efficient and doesn't introduce pointer dereferencing overhead.</p> </li> <li> <p>Functional Programming Style:</p> </li> <li> <p>This approach supports a functional programming style where the original object remains unchanged, and a modified copy is returned:</p> <pre><code>newAC := ac.SetRules(rules)\n</code></pre> </li> </ol>"},{"location":"advanced/pointers/#key-differences","title":"Key Differences","text":"Aspect Pointer Receiver (<code>*AccessControl</code>) Value Receiver (<code>AccessControl</code>) State Modification Modifies the original instance Modifies a copy of the instance Performance Avoids copying large structs Copies the struct Method Chaining Supports chaining Chaining requires extra assignment Immutability Mutates original Maintains immutability"},{"location":"advanced/pointers/#practical-recommendation","title":"Practical Recommendation","text":"<ul> <li>If the method is designed to modify the struct (e.g., setters like <code>SetRules</code>), use a pointer receiver (<code>*AccessControl</code>).</li> <li>If the method doesn't modify the struct and is meant to work on a copy or return a new version, use a value receiver (<code>AccessControl</code>).</li> </ul> <p>In your case, since <code>SetRules</code> is clearly a setter and modifies the <code>Rules</code> field, the pointer receiver version is the more appropriate choice.</p>"},{"location":"advanced/pointers/#examples","title":"Examples","text":""},{"location":"advanced/pointers/#1-creating-pointers-to-structs","title":"1. Creating Pointers to Structs","text":"<p>When you use <code>&amp;</code> before a type, you are creating a pointer to that type. For example:</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    // Create a pointer to a struct\n    p := &amp;Person{Name: \"Alice\", Age: 30}\n    fmt.Println(p)        // Output: &amp;{Alice 30}\n    fmt.Println(p.Name)   // Accessing fields via the pointer\n}\n</code></pre> <ul> <li>When to use:</li> <li>When you want to work with a pointer directly instead of a value.</li> <li>To avoid copying the entire struct when passing it around.</li> </ul>"},{"location":"advanced/pointers/#2-passing-pointers-to-functions","title":"2. Passing Pointers to Functions","text":"<p>When a function expects a pointer to a type, you use <code>&amp;</code> to pass the address of a value.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc updateAge(p *Person) {\n    p.Age = 35\n}\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    person := Person{Name: \"Bob\", Age: 30}\n    updateAge(&amp;person) // Passing a pointer to the struct\n    fmt.Println(person.Age) // Output: 35\n}\n</code></pre> <ul> <li>When to use:</li> <li>When you need the function to modify the original value (pass-by-reference behavior).</li> <li>When working with large data structures to avoid copying them.</li> </ul>"},{"location":"advanced/pointers/#3-using-new-for-pointer-initialization","title":"3. Using <code>new</code> for Pointer Initialization","text":"<p>You can use <code>new</code> to create pointers, but you can also use <code>&amp;</code> with a type literal for clarity:</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype Counter struct {\n    Value int\n}\n\nfunc main() {\n    // Using &amp; to create a pointer\n    c := &amp;Counter{Value: 1}\n    c.Value++\n    fmt.Println(c.Value) // Output: 2\n}\n</code></pre> <ul> <li>When to use:</li> <li>Use <code>&amp;</code> for explicit pointer creation alongside type initialization.</li> <li>Use <code>new</code> when no fields need initialization (<code>new(T)</code> returns <code>*T</code>).</li> </ul>"},{"location":"advanced/pointers/#4-dereferencing-and-modifying-values","title":"4. Dereferencing and Modifying Values","text":"<p>You use <code>&amp;</code> to create a pointer and <code>*</code> to dereference it:</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 10\n    ptr := &amp;x // Pointer to x\n    *ptr = 20 // Dereferencing the pointer to modify x\n    fmt.Println(x) // Output: 20\n}\n</code></pre> <ul> <li>When to use:</li> <li>Use <code>&amp;</code> when you want to reference a variable.</li> <li>Use <code>*</code> to modify or access the value pointed to by the pointer.</li> </ul>"},{"location":"advanced/pointers/#summary","title":"Summary","text":"<ul> <li> <p>Use <code>&amp;</code> when:</p> </li> <li> <p>You need a pointer to a type (e.g., <code>&amp;Struct{}</code>).</p> </li> <li>Passing variables by reference to avoid copying or to allow modification.</li> <li> <p>Initializing a pointer to a type inline.</p> </li> <li> <p>Don't use <code>&amp;</code> if:</p> </li> <li>You are fine with working with a copy of the value.</li> <li>The function does not require a pointer.</li> </ul>"},{"location":"advanced/pointers/#comparison","title":"Comparison","text":"<p>When deciding between using pointers (e.g., <code>&amp;Struct{}</code>) or values (e.g., <code>Struct{}</code>), the most efficient approach depends on several factors, including the size of the data, frequency of copying, and the specific use case. Here's a breakdown of efficiency considerations:</p>"},{"location":"advanced/pointers/#1-using-pointers-struct","title":"1. Using Pointers (<code>&amp;Struct{}</code>)","text":""},{"location":"advanced/pointers/#advantages","title":"Advantages","text":"<ul> <li> <p>Avoids Copying Large Data:</p> </li> <li> <p>When working with large structs, passing a pointer avoids copying the entire struct, which saves memory and CPU overhead.</p> </li> <li> <p>For example:</p> <pre><code>type LargeStruct struct {\n    Field1 [1024]byte\n    Field2 int\n}\n\n// Passing by value copies the entire structure\nfunc processByValue(data LargeStruct) {}\n\n// Passing by pointer avoids copying\nfunc processByPointer(data *LargeStruct) {}\n</code></pre> </li> <li> <p>Enables Mutability:</p> </li> <li> <p>Functions receiving pointers can modify the original data, avoiding the need to return modified copies.</p> </li> <li> <p>Useful in scenarios like in-place updates, caching, or synchronization primitives.</p> </li> <li> <p>Consistency for Shared Data:</p> </li> <li>If multiple parts of the program work on the same data, pointers ensure that changes are reflected everywhere.</li> </ul>"},{"location":"advanced/pointers/#disadvantages","title":"Disadvantages","text":"<ul> <li> <p>Potential for Nil Pointers:</p> </li> <li> <p>Pointers can be <code>nil</code>, leading to runtime panics if not checked properly.</p> </li> <li> <p>Example:</p> <pre><code>var p *Person\nfmt.Println(p.Name) // Causes panic\n</code></pre> </li> <li> <p>Dereferencing Overhead:</p> </li> <li> <p>Accessing data through a pointer incurs a slight overhead due to dereferencing.</p> </li> <li> <p>Garbage Collector Pressure:</p> </li> <li>Using pointers can increase the load on Go's garbage collector because the collector tracks heap allocations and pointers.</li> </ul>"},{"location":"advanced/pointers/#2-using-values-struct","title":"2. Using Values (<code>Struct{}</code>)","text":""},{"location":"advanced/pointers/#advantages_1","title":"Advantages","text":"<ul> <li> <p>Simpler Code:</p> </li> <li> <p>Avoids nil pointer dereference issues and makes code easier to reason about.</p> </li> <li> <p>Example:</p> <pre><code>person := Person{Name: \"Alice\", Age: 30}\nfmt.Println(person.Name) // Direct access, no pointer needed\n</code></pre> </li> <li> <p>Efficient for Small Data:</p> </li> <li> <p>Passing small structs (e.g., 2\u20133 fields) by value is efficient because copying them is inexpensive compared to the cost of managing pointers.</p> </li> <li> <p>Example:</p> <pre><code>type SmallStruct struct {\n    X, Y int\n}\n</code></pre> </li> <li> <p>Stack Allocation:</p> </li> <li>Value types are typically allocated on the stack, reducing garbage collector pressure.</li> </ul>"},{"location":"advanced/pointers/#disadvantages_1","title":"Disadvantages","text":"<ul> <li> <p>Expensive for Large Data:</p> </li> <li> <p>Copying large structs repeatedly can lead to performance degradation.</p> </li> <li> <p>Example:</p> <pre><code>type LargeStruct struct {\n    Field1 [1024]byte\n    Field2 int\n}\n</code></pre> </li> <li> <p>Immutability:</p> </li> <li>Functions working with values cannot modify the original data, leading to potentially unnecessary copies if changes are needed.</li> </ul>"},{"location":"advanced/pointers/#3-which-is-more-efficient","title":"3. Which Is More Efficient?","text":""},{"location":"advanced/pointers/#general-guidelines","title":"General Guidelines","text":"<ol> <li> <p>Use Pointers (<code>&amp;Struct{}</code>) when:</p> </li> <li> <p>The struct is large, or copying it would be expensive.</p> </li> <li>You need to modify the original data in functions.</li> <li>The data is shared between multiple parts of the program.</li> <li> <p>You are creating or working with linked data structures (e.g., trees, graphs).</p> </li> <li> <p>Use Values (<code>Struct{}</code>) when:</p> </li> <li>The struct is small, and copying is inexpensive.</li> <li>Immutability is acceptable or desirable.</li> <li>You want to avoid the complexity of managing pointers and nil checks.</li> <li>The struct will be short-lived and doesn't need to persist across function calls.</li> </ol>"},{"location":"advanced/pointers/#4-real-world-benchmarking","title":"4. Real-World Benchmarking","text":"<p>Benchmarking is the best way to decide. Here's an example of how you can test both approaches in your specific use case:</p> <pre><code>package main\n\nimport (\n \"testing\"\n)\n\ntype LargeStruct struct {\n Field1 [1024]byte\n Field2 int\n}\n\nfunc processByValue(data LargeStruct) {\n data.Field2 = 42\n}\n\nfunc processByPointer(data *LargeStruct) {\n data.Field2 = 42\n}\n\nfunc BenchmarkByValue(b *testing.B) {\n data := LargeStruct{}\n for i := 0; i &lt; b.N; i++ {\n  processByValue(data)\n }\n}\n\nfunc BenchmarkByPointer(b *testing.B) {\n data := &amp;LargeStruct{}\n for i := 0; i &lt; b.N; i++ {\n  processByPointer(data)\n }\n}\n</code></pre> <p>Run this benchmark using <code>go test -bench=.</code>, and you'll see the performance difference between the two approaches.</p>"},{"location":"advanced/pointers/#summary-comparison","title":"Summary Comparison","text":"<ul> <li>For small structs and immutable scenarios, use values for simplicity and performance.</li> <li>For large structs, mutable data, or shared state, use pointers to minimize copying and enable in-place updates.</li> <li>When in doubt, benchmark!</li> </ul>"},{"location":"files/encoders/","title":"Go <code>encoding</code>","text":"<p>In Go, the <code>encoding</code> package provides several encoders and decoders for different data formats. Besides <code>encoding/json</code> for JSON, there are a few other commonly used encoders and decoders. Here's an overview of the main ones:</p>"},{"location":"files/encoders/#summary-of-common-encodersdecoders","title":"Summary of Common Encoders/Decoders","text":"<ul> <li><code>encoding/json</code>: JSON format (text-based, lightweight).</li> <li><code>encoding/xml</code>: XML format (hierarchical, verbose).</li> <li><code>encoding/csv</code>: CSV format (tabular, text-based).</li> <li><code>encoding/gob</code>: Gob format (Go-specific, binary).</li> <li><code>encoding/base64</code>: Base64 (for encoding binary data as text).</li> <li><code>encoding/hex</code>: Hexadecimal encoding (binary data as hex).</li> <li><code>encoding/pem</code>: PEM format (used in cryptography).</li> <li><code>encoding/asn1</code>: ASN.1 format (used in cryptographic protocols).</li> </ul> <p>Each of these encoders provides functionality for encoding data to a specific format and decoding data from that format. Depending on your use case, you can choose the appropriate encoder for tasks such as serialization, communication, or file storage.</p>"},{"location":"files/encoders/#1-encodingjson-json-encodingdecoding","title":"1. encoding/json - JSON Encoding/Decoding","text":"<ul> <li>Package: <code>encoding/json</code></li> <li>Purpose: For encoding (marshaling) and decoding (unmarshaling) Go data structures to and from JSON format.</li> </ul> <p>Functions:</p> <ul> <li><code>json.Marshal</code>: Encodes Go data into JSON format.</li> <li><code>json.Unmarshal</code>: Decodes JSON data into Go structures.</li> <li><code>json.NewEncoder</code>: Creates a new encoder that can write JSON data to an <code>io.Writer</code>.</li> <li><code>json.NewDecoder</code>: Creates a new decoder that reads JSON from an <code>io.Reader</code>.</li> </ul>"},{"location":"files/encoders/#2-encodingxml-xml-encodingdecoding","title":"2. encoding/xml - XML Encoding/Decoding","text":"<ul> <li>Package: <code>encoding/xml</code></li> <li>Purpose: For encoding (marshaling) and decoding (unmarshaling) Go data structures to and from XML format.</li> </ul> <p>Functions:</p> <ul> <li><code>xml.Marshal</code>: Encodes Go data into XML format.</li> <li><code>xml.Unmarshal</code>: Decodes XML data into Go structures.</li> <li><code>xml.NewEncoder</code>: Creates a new encoder that can write XML data to an <code>io.Writer</code>.</li> <li><code>xml.NewDecoder</code>: Creates a new decoder that reads XML from an <code>io.Reader</code>.</li> </ul>"},{"location":"files/encoders/#3-encodingcsv-csv-encodingdecoding","title":"3. encoding/csv - CSV Encoding/Decoding","text":"<ul> <li>Package: <code>encoding/csv</code></li> <li>Purpose: For encoding (marshaling) and decoding (unmarshaling) Go data to and from CSV format.</li> </ul> <p>Functions:</p> <ul> <li><code>csv.NewReader</code>: Reads and parses CSV data from an <code>io.Reader</code>.</li> <li><code>csv.NewWriter</code>: Writes CSV data to an <code>io.Writer</code>.</li> <li><code>csv.Reader.Read</code>: Reads a single CSV record.</li> <li><code>csv.Writer.Write</code>: Writes a single CSV record.</li> </ul>"},{"location":"files/encoders/#4-encodinggob-gob-encodingdecoding","title":"4. encoding/gob - Gob Encoding/Decoding","text":"<ul> <li>Package: <code>encoding/gob</code></li> <li>Purpose: For encoding and decoding Go data structures to and from the Gob binary format. Gob is Go's native serialization format and is particularly efficient for Go-specific data types.</li> </ul> <p>Functions:</p> <ul> <li><code>gob.NewEncoder</code>: Creates a new encoder that writes Gob data to an <code>io.Writer</code>.</li> <li><code>gob.NewDecoder</code>: Creates a new decoder that reads Gob data from an <code>io.Reader</code>.</li> <li><code>gob.Encode</code>: Encodes a Go value into the Gob format.</li> <li><code>gob.Decode</code>: Decodes Gob data into a Go value.</li> </ul>"},{"location":"files/encoders/#5-encodingbase64-base64-encodingdecoding","title":"5. encoding/base64 - Base64 Encoding/Decoding","text":"<ul> <li>Package: <code>encoding/base64</code></li> <li>Purpose: For encoding and decoding binary data in Base64 format, which is commonly used for encoding binary data as text (such as for email or HTTP data).</li> </ul> <p>Functions:</p> <ul> <li><code>base64.StdEncoding.EncodeToString</code>: Encodes data into a Base64 string.</li> <li><code>base64.StdEncoding.DecodeString</code>: Decodes a Base64 encoded string.</li> <li><code>base64.NewEncoder</code>: Encodes data to an <code>io.Writer</code> in Base64.</li> <li><code>base64.NewDecoder</code>: Decodes Base64 data from an <code>io.Reader</code>.</li> </ul>"},{"location":"files/encoders/#6-encodinghex-hex-encodingdecoding","title":"6. encoding/hex - Hex Encoding/Decoding","text":"<ul> <li>Package: <code>encoding/hex</code></li> <li>Purpose: For encoding and decoding binary data into hexadecimal format.</li> </ul> <p>Functions:</p> <ul> <li><code>hex.EncodeToString</code>: Encodes a byte slice to a hexadecimal string.</li> <li><code>hex.DecodeString</code>: Decodes a hexadecimal string into a byte slice.</li> <li><code>hex.NewEncoder</code>: Writes hexadecimal-encoded data to an <code>io.Writer</code>.</li> <li><code>hex.NewDecoder</code>: Reads and decodes hexadecimal data from an <code>io.Reader</code>.</li> </ul>"},{"location":"files/encoders/#7-encodingpem-pem-encodingdecoding","title":"7. encoding/pem - PEM Encoding/Decoding","text":"<ul> <li>Package: <code>encoding/pem</code></li> <li>Purpose: For encoding and decoding data in PEM (Privacy-Enhanced Mail) format, commonly used for certificates and cryptographic keys.</li> </ul> <p>Functions:</p> <ul> <li><code>pem.Encode</code>: Encodes a <code>pem.Block</code> to a writer.</li> <li><code>pem.Decode</code>: Decodes a PEM-encoded block from a reader.</li> <li><code>pem.Block</code>: A structure representing a PEM-encoded block of data, such as a certificate or key.</li> </ul>"},{"location":"files/encoders/#8-encodingasn1-asn1-encodingdecoding","title":"8. encoding/asn1 - ASN.1 Encoding/Decoding","text":"<ul> <li>Package: <code>encoding/asn1</code></li> <li>Purpose: For encoding and decoding data using the Abstract Syntax Notation One (ASN.1) format, commonly used for certificates, cryptographic keys, and other protocols.</li> </ul> <p>Functions:</p> <ul> <li><code>asn1.Marshal</code>: Encodes Go values to ASN.1 format.</li> <li><code>asn1.Unmarshal</code>: Decodes ASN.1 data to Go values.</li> </ul>"},{"location":"files/files/","title":"Read and Write from/to Files","text":"<p>In Go, you can read from and write to text files using the <code>os</code> and <code>bufio</code> packages (for more control). Below are examples of how to read from and write to text files in Go.</p>"},{"location":"files/files/#key-points","title":"Key Points","text":"<ul> <li><code>os.ReadFile</code>: Reads the entire file into memory (ideal for smaller files).</li> <li><code>bufio.Scanner</code>: Reads the file line-by-line, which is memory efficient for larger files.</li> <li><code>os.WriteFile</code>: Writes the content to a file, overwriting any existing content.</li> <li><code>os.OpenFile</code>: Opens a file and provides more control, such as appending content.</li> </ul> <p>These examples should give you a solid foundation for working with text files in Go.</p>"},{"location":"files/files/#reading-a-text-file","title":"Reading a Text File","text":"<p>Here\u2019s how you can read a text file in Go:</p>"},{"location":"files/files/#1-using-osreadfile-go-116","title":"1. Using <code>os.ReadFile</code> (Go 1.16+)","text":"<p>This is the simplest and recommended way to read an entire file in Go.</p> <pre><code>package main\n\nimport (\n \"fmt\"\n \"os\"\n)\n\nfunc main() {\n // Reading file content\n data, err := os.ReadFile(\"example.txt\")\n if err != nil {\n  fmt.Println(\"Error reading file:\", err)\n  return\n }\n\n // Print the content of the file\n fmt.Println(string(data))\n}\n</code></pre>"},{"location":"files/files/#2-using-bufioscanner-more-control","title":"2. Using <code>bufio.Scanner</code> (More Control)","text":"<p>If you need to read the file line by line, you can use the <code>bufio</code> package to scan through the file.</p> <pre><code>package main\n\nimport (\n \"bufio\"\n \"fmt\"\n \"os\"\n)\n\nfunc main() {\n file, err := os.Open(\"example.txt\")\n if err != nil {\n  fmt.Println(\"Error opening file:\", err)\n  return\n }\n defer file.Close()\n\n // Create a scanner to read the file line by line\n scanner := bufio.NewScanner(file)\n for scanner.Scan() {\n  fmt.Println(scanner.Text()) // Print each line\n }\n\n if err := scanner.Err(); err != nil {\n  fmt.Println(\"Error reading file:\", err)\n }\n}\n</code></pre>"},{"location":"files/files/#writing-to-a-text-file","title":"Writing to a Text File","text":"<p>To write to a text file, you can use the <code>os</code> package for opening/creating files and <code>io</code> or <code>bufio</code> for writing.</p>"},{"location":"files/files/#1-using-oswritefile-go-116","title":"1. Using <code>os.WriteFile</code> (Go 1.16+)","text":"<p>This method is simple and suitable when you want to overwrite the content of the file.</p> <pre><code>package main\n\nimport (\n \"fmt\"\n \"os\"\n)\n\nfunc main() {\n content := []byte(\"Hello, this is a sample text file.\")\n\n // Writing to the file\n err := os.WriteFile(\"output.txt\", content, 0644)\n if err != nil {\n  fmt.Println(\"Error writing file:\", err)\n  return\n }\n\n fmt.Println(\"File written successfully!\")\n}\n</code></pre>"},{"location":"files/files/#2-using-bufiowriter-more-control","title":"2. Using <code>bufio.Writer</code> (More Control)","text":"<p>If you need more control, such as appending data or writing line by line, you can use the <code>bufio.Writer</code>:</p> <pre><code>package main\n\nimport (\n \"bufio\"\n \"fmt\"\n \"os\"\n)\n\nfunc main() {\n // Open the file in write mode, create it if it doesn't exist\n file, err := os.OpenFile(\"output.txt\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)\n if err != nil {\n  fmt.Println(\"Error opening file:\", err)\n  return\n }\n defer file.Close()\n\n // Create a buffered writer\n writer := bufio.NewWriter(file)\n\n // Write data to the file\n _, err = writer.WriteString(\"Hello, this is another line of text!\\n\")\n if err != nil {\n  fmt.Println(\"Error writing to file:\", err)\n  return\n }\n\n // Make sure to flush the buffer to the file\n writer.Flush()\n\n fmt.Println(\"Text written to file successfully!\")\n}\n</code></pre>"},{"location":"files/html_templates/","title":"Go <code>HTML</code> Template Rendering","text":"<p>Go provides built-in support for working with HTML content through the <code>html/template</code> package. This package helps to separate logic from presentation, allowing dynamic content to be safely inserted into HTML pages. It is especially useful for generating web pages based on templates and user data.</p>"},{"location":"files/html_templates/#template-example","title":"Template Example","text":""},{"location":"files/html_templates/#template-file-templatesindexhtml","title":"Template File: <code>templates/index.html</code>","text":"<p>The following is an example of an HTML template that contains placeholders for dynamic content. These placeholders will be replaced at runtime using data passed from your Go code.</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1, minimum-scale=1\"\n    /&gt;\n    &lt;title&gt;{{.Meta.Title}}&lt;/title&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;h1&gt;{{.Heading}}&lt;/h1&gt;\n    &lt;p&gt;{{.Content}}&lt;/p&gt;\n\n    &lt;!-- Array/Slice --&gt;\n    &lt;ul&gt;\n      {{range .Items}}\n      &lt;li&gt;{{.}}&lt;/li&gt;\n      {{end}}\n    &lt;/ul&gt;\n\n    &lt;!-- IF-Statement --&gt;\n    {{if .User.IsAuthenticated}}\n    &lt;h1&gt;Welcome back, {{.User.Username}}!&lt;/h1&gt;\n    {{else}}\n    &lt;h1&gt;Welcome, Guest!&lt;/h1&gt;\n    {{end}}\n\n    &lt;!-- Switch --&gt;\n    {{if eq .User.Role.Name \"admin\"}}\n    &lt;h1&gt;Admin Panel&lt;/h1&gt;\n    {{else if eq .User.Role.Name \"user\"}}\n    &lt;h1&gt;User Dashboard&lt;/h1&gt;\n    {{else}}\n    &lt;h1&gt;Access Denied&lt;/h1&gt;\n    {{end}}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>In this template:</p> <ul> <li><code>{{.Heading}}</code>, <code>{{.Content}}</code> and <code>{{.ETC...}}</code> are placeholders that will be replaced by data passed to the template when rendering it.</li> </ul>"},{"location":"files/html_templates/#go-file-maingo","title":"Go File: <code>main.go</code>","text":"<p>This Go code reads the template file, creates data to populate the placeholders, and renders the final HTML.</p> <pre><code>package main\n\nimport (\n \"bytes\"\n \"fmt\"\n \"html/template\"\n \"os\"\n)\n\n// Dict is a type alias for a map with string keys and values of any type.\n// It is used to pass a flexible data structure to templates.\ntype Dict = map[string]interface{}\n\n// List is a type alias for a slice of interface{}, typically used for handling ordered collections of mixed types in templates.\ntype List = []interface{}\n\nfunc main() {\n // Define a template string by reading the contents of an HTML template file.\n var tmpl = readFile(\"templates/index.html\")\n\n // Create a User instance with default values.\n user := User{\n  IsAuthenticated: true,\n  Username:        \"John\",\n  Role:            Role{Name: \"user\"},\n }\n\n // Create a data structure to hold dynamic values for rendering.\n // These values will be passed to the template during execution.\n data := Dict{\n  \"User\": user, // Pass the user object to the template.\n  \"Heading\": \"Welcome to Go Templates!\",                                                                               // Page heading.\n  \"Content\": template.HTML(\"&lt;strong&gt;This is a dynamic HTML page generated using the html/template package.&lt;/strong&gt;\"), // Dynamic content to render.\n  \"Items\":   List{\"Item 1\", \"Item 2\", \"Item 3\"},                                                                       // A list of items to display.\n  \"Meta\": Dict{\n   \"Title\": \"My Go HTML Template\", // Dynamic metadata for the page.\n  },\n }\n\n // Use the HTML helper function to render the template.\n render := HTML(tmpl) // Get a function to render the template.\n html := render(data) // Call the render function with the data.\n fmt.Println(html)    // Output the rendered HTML to the console.\n}\n\n// HTML takes a template string and returns a function that renders the template with the given data.\n// This allows for easy reuse of the template rendering logic with different sets of data.\nfunc HTML(tmpl string) func(data interface{}) string {\n // Parse the template string into a Template object.\n t, err := template.New(\"webpage\").Parse(tmpl)\n if err != nil {\n  // Panic if there's an error parsing the template.\n  panic(err)\n }\n\n // Return a function that renders the template with the provided data.\n return func(data interface{}) string {\n  // Create a buffer to capture the output of the template rendering.\n  var buf bytes.Buffer\n  // Execute the template, passing in the data.\n  err = t.Execute(&amp;buf, data)\n  if err != nil {\n   // Panic if there's an error executing the template.\n   panic(err)\n  }\n\n  // Return the generated HTML as a string.\n  return buf.String()\n }\n}\n\n// readFile reads the contents of a file at the given path and returns it as a string.\n// It panics if there is an error reading the file.\nfunc readFile(filePath string) string {\n data, err := os.ReadFile(filePath)\n if err != nil {\n  // Panic if there's an error reading the file.\n  panic(err)\n }\n return string(data)\n}\n\n// Role defines the structure for a user's role in the application.\n// It contains an ID, Name, and Level to indicate the role's priority.\ntype Role struct {\n ID    uint   // Unique identifier for the role.\n Name  string // Name of the role.\n Level uint   // The level or rank of the role.\n}\n\n// User represents a user in the application.\n// It includes personal details, role, and flags for authentication and account status.\ntype User struct {\n ID uint // Unique identifier for the user.\n\n // Role and account information\n Role     Role   // Role associated with the user.\n Username string // Username for the user.\n Email    string // Email address of the user.\n Password string // User's password (hashed for security).\n\n // Personal details\n FirstName  string // User's first name.\n MiddleName string // User's middle name (optional).\n LastName   string // User's last name.\n\n // Flags indicating the user's status\n IsStaff         bool // Whether the user is a staff member.\n IsActive        bool // Whether the user is active.\n IsSuperuser     bool // Whether the user is a superuser.\n IsAuthenticated bool // Whether the user is authenticated.\n\n // DateTime fields to track events for the user\n CreatedAt string // Timestamp for when the user was created (using string for simplicity, ideally time.Time).\n UpdatedAt string // Timestamp for the last update to the user's information.\n DeletedAt string // Timestamp for when the user was deleted (if applicable).\n}\n</code></pre>"},{"location":"files/html_templates/#key-concepts","title":"Key Concepts","text":"<ul> <li>Templates: Templates are HTML files with placeholders (e.g., <code>{{.Title}}</code>) that can be dynamically replaced with data.</li> <li>Data: The data is passed to the template as a map (of type <code>Dict</code>) that maps variable names (e.g., <code>Title</code>, <code>Heading</code>, <code>Content</code>) to their values.</li> <li>Rendering: The template is parsed and executed with the provided data to generate the final HTML content.</li> <li>HTML Safety: The <code>template.HTML</code> type ensures that HTML content is not automatically escaped when rendering.</li> </ul>"},{"location":"files/html_templates/#how-it-works","title":"How It Works","text":"<ol> <li>Template Parsing: The <code>html/template</code> package is used to parse the <code>index.html</code> file.</li> <li>Dynamic Data Insertion: The placeholders in the HTML template (e.g., <code>{{.Title}}</code>) are replaced with values from the <code>data</code> map.</li> <li>Rendering: The <code>Execute</code> method renders the template with the data and returns the result as a string.</li> </ol>"},{"location":"files/html_templates/#conclusion","title":"Conclusion","text":"<p>This example demonstrates how to use Go's <code>html/template</code> package for rendering dynamic HTML content. By passing data to templates, you can easily generate HTML pages with dynamic content, ensuring a clean separation of presentation and business logic in your Go applications.</p>"},{"location":"files/json_load_dump/","title":"Go <code>JSON</code>","text":"<p>Go provides built-in support for working with the JSON data format through the <code>encoding/json</code> package. This includes powerful encoders and decoders for marshaling (converting Go structs to JSON) and unmarshaling (parsing JSON into Go structs).</p> <p>File: <code>data/input.json</code></p> <pre><code>{\n  \"name\": \"John Doe\",\n  \"age\": 30,\n  \"email\": \"john.doe@example.com\",\n  \"skills\": [\"Go\", \"Python\", \"JavaScript\"]\n}\n</code></pre> <p>File: <code>main.go</code></p> <pre><code>package main\n\nimport (\n \"encoding/json\"\n \"fmt\"\n \"log\"\n \"os\"\n)\n\n// User struct defines the structure of the JSON data we are working with.\n// The struct tags (e.g., `json:\"name\"`) map JSON field names to struct fields.\ntype User struct {\n Name   string   `json:\"name\"`   // User's name\n Age    int      `json:\"age\"`    // User's age\n Email  string   `json:\"email\"`  // User's email address\n Skills []string `json:\"skills\"` // List of user's skills\n}\n\n// check is a utility function for error handling. If an error occurs,\n// it logs the error message and stops the program.\nfunc check(e error) {\n if e != nil {\n  log.Fatalf(\"Failed with ERROR: %v\", e)\n  panic(e)\n }\n}\n\n// LoadsJson demonstrates how to read and parse JSON data from a file into a Go struct.\nfunc LoadsJson() {\n // Read the JSON file's content.\n // This function reads the file \"data/input.json\" and returns its contents as a byte slice.\n data, err := os.ReadFile(\"data/input.json\")\n check(err)\n\n // Declare a variable of type `User` to hold the parsed data.\n var user User\n\n // Parse the JSON data into the `user` variable.\n // `json.Unmarshal` converts the JSON data into the Go struct based on matching field names.\n err = json.Unmarshal(data, &amp;user)\n check(err)\n\n // Display the parsed data to the console in a human-readable format.\n fmt.Println(\"Parsed JSON Data:\")\n fmt.Printf(\"Name: %s\\n\", user.Name)\n fmt.Printf(\"Age: %d\\n\", user.Age)\n fmt.Printf(\"Email: %s\\n\", user.Email)\n fmt.Printf(\"Skills: %v\\n\", user.Skills)\n}\n\n// DumpsJson demonstrates how to create a Go struct, convert it to JSON,\n// and write the JSON data to a file.\nfunc DumpsJson() {\n // Create an instance of the `User` struct with sample data.\n user := User{\n  Name:   \"John Doe\",                                // Name of the user\n  Age:    30,                                       // Age of the user\n  Email:  \"john.doe@example.com\",                   // Email of the user\n  Skills: []string{\"Go\", \"Python\", \"JavaScript\"},   // List of skills\n }\n\n // Convert the Go struct to a JSON-formatted byte slice with indentation.\n // `json.MarshalIndent` adds formatting to make the output more readable.\n userJSON, err := json.MarshalIndent(user, \"\", \"  \")\n check(err)\n\n // Write the JSON data to a file called \"data/output.json\".\n // `0644` sets the file permissions so that the owner can read/write, and others can only read.\n err = os.WriteFile(\"data/output.json\", userJSON, 0644)\n check(err)\n\n fmt.Println(\"JSON data successfully written to output.json\")\n}\n\n// main is the entry point of the program. It calls both `LoadsJson` and `DumpsJson`\n// to demonstrate reading from and writing to JSON files.\nfunc main() {\n LoadsJson()\n DumpsJson()\n}\n</code></pre>"},{"location":"numbers/limits/","title":"Numbers Limits","text":""},{"location":"numbers/limits/#integer","title":"Integer","text":"<p>The range for an <code>int64</code> in Go is based on its size (64 bits) and the two's complement representation used for signed integers:</p> <pre><code>9223372036854775807\n</code></pre>"},{"location":"numbers/limits/#range-of-int64","title":"Range of <code>int64</code>","text":"<ul> <li>Minimum value: <code>-9,223,372,036,854,775,808</code> (i.e., <code>-(2^63)</code>)</li> <li>Maximum value: <code>9,223,372,036,854,775,807</code> (i.e., <code>2^63 - 1</code>)</li> </ul>"},{"location":"numbers/limits/#key-points","title":"Key Points","text":"<ul> <li><code>int64</code> is a signed 64-bit integer.</li> <li>It can represent approximately \u00b19.2 quintillion.</li> </ul> <p>This makes <code>int64</code> ideal for large numerical computations or cases requiring very large integer ranges. If you don't need negative values, you can use <code>uint64</code>, which has a range of <code>0</code> to <code>18,446,744,073,709,551,615</code> (i.e., <code>2^64 - 1</code>).</p>"},{"location":"numbers/limits/#float","title":"Float","text":"<p>The range for a <code>float64</code> in Go (as defined by the IEEE 754 standard for 64-bit floating-point numbers) is:</p>"},{"location":"numbers/limits/#min","title":"Min","text":"<pre><code>0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005\n</code></pre>"},{"location":"numbers/limits/#max","title":"Max","text":"<pre><code>179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000\n</code></pre>"},{"location":"numbers/limits/#positive-range","title":"Positive Range","text":"<ul> <li>Smallest positive non-zero value (denormalized): <code>5e-324</code></li> <li>Largest positive value: <code>1.7976931348623157e+308</code></li> </ul>"},{"location":"numbers/limits/#negative-range","title":"Negative Range","text":"<ul> <li>Largest negative value: <code>-1.7976931348623157e+308</code></li> <li>Smallest negative non-zero value (denormalized): <code>-5e-324</code></li> </ul>"},{"location":"numbers/limits/#special-values","title":"Special Values","text":"<ul> <li>Zero: <code>0</code> (positive and negative)</li> <li>Infinity: <code>+Inf</code> and <code>-Inf</code></li> <li>Not a Number (NaN): Represents undefined or unrepresentable values (e.g., <code>0/0</code>).</li> </ul>"},{"location":"numbers/limits/#precision","title":"Precision","text":"<ul> <li>A <code>float64</code> provides approximately 15\u201317 decimal digits of precision.</li> </ul> <p>This makes <code>float64</code> suitable for a wide range of scientific and engineering applications requiring high precision and a large range of values.</p>"},{"location":"numbers/limits/#safe-numbers-javascript-and-business-logic","title":"Safe Numbers (JavaScript and Business Logic)","text":"Title Number Notes Minimum <code>0.00001</code> (100 Thousandth) Minimum safe decimal precision for user input Maximum <code>1000000000</code> (1 Billion) Maximum safe integer for business logic Safe Numbers <code>1000000000.00001</code> (1 Billion + 100 Thousandth) Decimals =&gt; <code>SQL_DECIMAL(15, 5)</code> Storage Max Integer <code>1000000000000000000</code> (1 Quintillion) Maximum value supported by Database/GoLang storage <pre><code>// ------------------------------------------------------------------------\n// Safe Numbers (JavaScript and Business Logic)\n// ------------------------------------------------------------------------\n\nconst (\n // MinSafeDecimal represents the smallest safe decimal value for user input.\n MinSafeDecimal float64 = 0.00001 // (100 Thousandth)\n\n // MaxSafeInteger represents the largest safe integer value for business logic.\n MaxSafeInteger int64 = 1000000000 // (1 Billion)\n\n // MaxSafeNumbers represents the largest safe decimal value for precision.\n MaxSafeNumbers float64 = 1000000000.00001 // (1 Billion + 100 Thousandth)\n\n // StorageMaxInteger represents the maximum value supported by database/GoLang storage.\n StorageMaxInteger int64 = 1000000000000000000 // (1 Quintillion)\n)\n</code></pre>"},{"location":"packages/layout/","title":"New Projects Layout","text":"<p>Go emphasizes simplicity and modularity. With frameworks like Gin, Echo, or plain Go, Go projects often follow a structure inspired by Clean Architecture or Domain-Driven Design.</p>"},{"location":"packages/layout/#standard-go-project-layout","title":"Standard Go Project Layout","text":"<ul> <li>Golang Standards</li> </ul>"},{"location":"packages/layout/#ready-to-go-layout","title":"Ready to <code>GO</code> Layout","text":"<ul> <li>Custom Layout</li> </ul> <p>Create Layout:</p> <pre><code>mkdir -p build/{ci,package} internal/{app,pkg} web/{app,middleware,static,template} \\\nassets cmd config deployments docs examples pkg scripts tests tools\n</code></pre> <p>Clone Layout:</p> <pre><code>git clone https://github.com/hlop3z/project-layout-go.git &amp;&amp; rm -rf project-layout-go/.git\n</code></pre>"},{"location":"packages/layout/#example-go-multiple-directories-layout-clean-architecture","title":"Example: Go Multiple Directories Layout (Clean Architecture)","text":"<pre><code>{your_project}/\n\u251c\u2500\u2500 assets/                     # ~ Static assets such as images, fonts, etc.\n\u251c\u2500\u2500 build/                      # ~ Build-related files and configurations\n\u2502   \u251c\u2500\u2500 ci/                     # Continuous Integration configurations (e.g., GitHub Actions, CircleCI)\n\u2502   \u2514\u2500\u2500 package/                # Packaging configurations (e.g., Docker, tarballs)\n\u251c\u2500\u2500 cmd/                        # ~ Entry points for commands (main package)\n\u2502   \u2514\u2500\u2500 {your_app}/             # Application command for starting the app, handling migrations, etc.\n\u251c\u2500\u2500 config/                     # ~ Configuration files for different environments (e.g., dev, prod)\n\u251c\u2500\u2500 deployments/                # ~ Deployment-related configurations and scripts\n\u251c\u2500\u2500 docs/                       # ~ Documentation files for the project\n\u251c\u2500\u2500 examples/                   # ~ Example configurations or use cases for developers\n\u251c\u2500\u2500 internal/                   # ~ Internal application logic (not to be exposed publicly)\n\u2502   \u251c\u2500\u2500 app/                    # Internal application logic for handling requests, business rules\n\u2502   \u2502   \u2514\u2500\u2500 {your_app}/         # Specific logic for your application\u2019s core functionality\n\u2502   \u2514\u2500\u2500 pkg/                    # Internal reusable packages (e.g., shared utilities, helpers)\n\u2502       \u2514\u2500\u2500 {your_private_lib}/ # Private library with internal functions and methods\n\u251c\u2500\u2500 pkg/                        # ~ Public packages that can be reused by other applications\n\u2502   \u2514\u2500\u2500 {your_public_lib}/      # Reusable public library with functionality exposed for external use\n\u251c\u2500\u2500 scripts/                    # ~ Utility scripts for tasks like database migration, deployment, etc.\n\u251c\u2500\u2500 tests/                      # ~ Unit and integration tests for the application\n\u251c\u2500\u2500 tools/                      # ~ Developer tools and utilities (e.g., code generators, linters)\n\u251c\u2500\u2500 web/                        # ~ Web application-specific files (server-side)\n\u2502   \u251c\u2500\u2500 app/                    # Core web application logic (controllers, views)\n\u2502   \u251c\u2500\u2500 static/                 # Static files served by the web server (CSS, JS, images)\n\u2502   \u2514\u2500\u2500 template/               # Template files for rendering views (HTML, JSX, etc.)\n\u251c\u2500\u2500 go.mod                      # ~ (Package/Module) =&gt; github.com/YOUR_USER_OR_ORG_NAME/YOUR_REPO_NAME\n\u2514\u2500\u2500 {etc ...}                   # All other files and directories\n</code></pre>"},{"location":"packages/layout/#example-go-single-directory-layout","title":"Example: Go Single Directory Layout","text":"<pre><code>module/\n\u251c\u2500\u2500 main.go             # Entry point of the application\n\u251c\u2500\u2500 types.go            # Defines data structures, constants, and interfaces\n\u251c\u2500\u2500 config.go           # Handles configuration loading and parsing\n\u251c\u2500\u2500 handlers.go         # HTTP handlers or main API endpoints\n\u251c\u2500\u2500 services.go         # Business logic and application services\n\u251c\u2500\u2500 repository.go       # Handles database or external data access\n\u251c\u2500\u2500 middleware.go       # Defines HTTP middleware (e.g., auth, logging)\n\u251c\u2500\u2500 routes.go           # Sets up and manages HTTP routes\n\u251c\u2500\u2500 utils.go            # Utility/helper functions\n\u251c\u2500\u2500 helpers.go          # Helper/utility functions\n\u2514\u2500\u2500 errors.go           # Custom error definitions and error handling utilities\n</code></pre>"},{"location":"packages/domains/web/","title":"Web Frameworks","text":"<p>If you\u2019re looking for the most lightweight tool to create APIs in Go, without adding too much overhead, Gin and Echo are the top contenders. However, if you're looking for something ultra-lightweight, here's a comparison along with some recommendation:</p>"},{"location":"packages/domains/web/#summary-of-options","title":"Summary of Options","text":"Framework Lightweight? Features Use Case Pros Cons Gin Yes Routing, middleware, JSON RESTful APIs Very fast, minimalistic Somewhat opinionated Echo Yes Routing, middleware, WebSockets, validation RESTful, web apps Fast, easy-to-use More features than Gin Chi Yes Routing, middleware Microservices, small apps Minimalistic, extensible Needs more manual work for features net/http Yes Custom routing, manual setup Custom APIs No external dependencies Requires manual handling of routing, errors"},{"location":"packages/domains/web/#recommendation","title":"Recommendation:","text":"<p>If you want the most lightweight solution:</p> <ol> <li><code>net/http</code> if you want zero dependencies and control over everything.</li> <li><code>Chi</code> if you want minimal routing and to add features only as needed (best for microservices).</li> <li><code>Gin</code> if you want performance with an out-of-the-box feature set (great balance).</li> </ol>"},{"location":"packages/domains/web/#1-nethttp-pure-go","title":"1. net/http (Pure Go)","text":"<ul> <li>Purpose: Standard library package for HTTP servers.</li> <li>Features:</li> <li>No extra dependencies.</li> <li>Everything done by you: routing, request handling, middleware.</li> </ul> <pre><code>import (\n \"net/http\"\n)\n\nfunc main() {\n http.HandleFunc(\"/hello\", func(w http.ResponseWriter, r *http.Request) {\n  w.Write([]byte(\"Hello, World!\"))\n })\n\n http.ListenAndServe(\":8080\", nil)\n}\n</code></pre> <p>Pros:</p> <ul> <li>No dependencies.</li> <li>Ultra-lightweight and native Go.</li> </ul> <p>Cons:</p> <ul> <li>Manually handle routing, error handling, etc.</li> <li>Not as feature-rich as frameworks like Gin or Echo.</li> </ul>"},{"location":"packages/domains/web/#2-gin","title":"2. Gin","text":"<ul> <li>Purpose: Fast, small, and high-performance web framework for Go.</li> <li> <p>Features:</p> </li> <li> <p>Routing, middleware, JSON handling.</p> </li> <li>Built-in features for web APIs (JSON validation, rendering, etc.).</li> <li>Very fast (close to <code>net/http</code> speed).</li> <li> <p>Easy-to-use, good documentation.</p> </li> <li> <p>Use Case: Perfect for building RESTful APIs, web services with minimal overhead.</p> </li> </ul> <pre><code>import (\n \"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n r := gin.Default()\n\n r.GET(\"/hello\", func(c *gin.Context) {\n  c.JSON(200, gin.H{\n   \"message\": \"Hello, World!\",\n  })\n })\n\n r.Run(\":8080\")\n}\n</code></pre> <p>Pros:</p> <ul> <li>Fast and simple.</li> <li>Good balance between features and performance.</li> </ul> <p>Cons:</p> <ul> <li>Somewhat opinionated (but still lightweight).</li> </ul>"},{"location":"packages/domains/web/#3-echo","title":"3. Echo","text":"<ul> <li>Purpose: Fast and minimalist web framework for Go.</li> <li>Features:</li> <li>Router, middleware, request validation, and rendering.</li> <li>Also fast but with a little more structure than Gin.</li> <li>Supports HTTP/2, WebSockets, and more advanced features.</li> </ul> <pre><code>import (\n \"github.com/labstack/echo/v4\"\n)\n\nfunc main() {\n e := echo.New()\n\n e.GET(\"/hello\", func(c echo.Context) error {\n  return c.JSON(200, map[string]string{\n   \"message\": \"Hello, World!\",\n  })\n })\n\n e.Logger.Fatal(e.Start(\":8080\"))\n}\n</code></pre> <p>Pros:</p> <ul> <li>Fast, easy routing.</li> <li>Good docs and slightly more structured than Gin.</li> </ul> <p>Cons:</p> <ul> <li>A bit more features than Gin, though still very lightweight.</li> </ul>"},{"location":"packages/domains/web/#4-chi","title":"4. Chi","text":"<ul> <li>Purpose: Ultra-lightweight router for Go.</li> <li>Features:</li> <li>Focuses on routing and is incredibly minimal.</li> <li>Small memory footprint, works well for microservices.</li> <li>Extensible with middleware (but you get to decide what you want).</li> </ul> <pre><code>import (\n \"github.com/go-chi/chi\"\n \"net/http\"\n)\n\nfunc main() {\n r := chi.NewRouter()\n\n r.Get(\"/hello\", func(w http.ResponseWriter, r *http.Request) {\n  w.Write([]byte(\"Hello, World!\"))\n })\n\n http.ListenAndServe(\":8080\", r)\n}\n</code></pre> <p>Pros:</p> <ul> <li>Minimal \u2014 just routing, with extensible middleware.</li> <li>Great for very small services or microservices.</li> <li>Supports middleware and context.</li> </ul> <p>Cons:</p> <ul> <li>Minimal by design, so you might need to implement some features manually.</li> </ul>"},{"location":"packages/vendors/echo/","title":"ECHO","text":"<p>Package main demonstrates a simple web server using the Echo framework.</p>"},{"location":"packages/vendors/echo/#this-server-provides-the-following-functionality","title":"This server provides the following functionality","text":"<ol> <li>Serves a personalized <code>Hello, World!</code> message on the root (\"/\") endpoint.</li> <li>Handles a <code>POST</code> request to create and validate user data on the \"/users\" endpoint.</li> <li>Logs all registered routes to a <code>JSON</code> file.</li> </ol> <pre><code>package main\n\nimport (\n \"encoding/json\"\n \"fmt\"\n \"log\"\n \"net/http\"\n \"os\"\n\n \"github.com/go-playground/validator/v10\"\n \"github.com/labstack/echo/v4\"\n)\n\n// User represents the structure for user data.\n// It includes:\n// - Name: The name of the user (required).\n// - Email: The email address of the user (required and must be in a valid email format).\ntype User struct {\n Name  string `json:\"name\" validate:\"required\"`\n Email string `json:\"email\" validate:\"required,email\"`\n}\n\n// CustomValidator wraps the validator library to implement Echo's Validator interface.\n// This allows request payloads to be validated automatically in handlers.\ntype CustomValidator struct {\n validator *validator.Validate\n}\n\n// Validate applies validation rules to the given struct and returns an HTTP error\n// if validation fails.\nfunc (cv *CustomValidator) Validate(i interface{}) error {\n if err := cv.validator.Struct(i); err != nil {\n  // Return a 400 Bad Request error with the validation error message.\n  return echo.NewHTTPError(http.StatusBadRequest, err.Error())\n }\n return nil\n}\n\n// Get Demo\nfunc pageHome(c echo.Context) error {\n // Get the \"name\" query parameter from the request.\n name := c.QueryParam(\"name\")\n if name == \"\" {\n  name = \"World\"\n }\n\n // Format and respond with an HTML message.\n message := fmt.Sprintf(\"&lt;strong&gt;Hello, %v!&lt;/strong&gt;\", name)\n return c.HTML(http.StatusOK, message)\n}\n\n// Post Demo\nfunc pageUser(c echo.Context) error {\n // Bind the incoming JSON payload to the User struct.\n u := new(User)\n if err := c.Bind(u); err != nil {\n  // Return a 400 Bad Request error if binding fails.\n  return echo.NewHTTPError(http.StatusBadRequest, \"Invalid request payload\")\n }\n\n // Validate the User struct using the custom validator.\n if err := c.Validate(u); err != nil {\n  // Return validation errors if the user data is invalid.\n  return err\n }\n\n // Respond with the validated user data in JSON format.\n return c.JSON(http.StatusOK, u)\n}\n\n// initializeRoutes initializes the routes for the Echo application.\n// It also logs all registered routes to a JSON file.\nfunc initializeRoutes(app *echo.Echo) {\n // Define the root (\"/\") endpoint.\n app.GET(\"/\", pageHome)\n\n // Define the \"/users\" endpoint for user data validation.\n app.POST(\"/users\", pageUser).Name = \"get-user\"\n\n // Define the static (\"/static\") endpoint.\n app.Static(\"/static\", \"static\")\n\n // Log all registered routes to a JSON file.\n routesFile := \"data/routes.json\"\n if err := logRoutesToFile(app, routesFile); err != nil {\n  log.Printf(\"Failed to log routes to file: %v\", err)\n }\n}\n\n// logRoutesToFile logs all registered routes to a specified JSON file.\nfunc logRoutesToFile(app *echo.Echo, filename string) error {\n routes := app.Routes()\n data, err := json.MarshalIndent(routes, \"\", \"  \")\n if err != nil {\n  return fmt.Errorf(\"failed to marshal routes: %w\", err)\n }\n\n if err := os.WriteFile(filename, data, 0644); err != nil {\n  return fmt.Errorf(\"failed to write routes to file: %w\", err)\n }\n\n log.Printf(\"Routes logged to %s\", filename)\n return nil\n}\n\n// main initializes and starts the Echo web server.\nfunc main() {\n // Create a new Echo instance.\n app := echo.New()\n\n // Register a custom validator.\n app.Validator = &amp;CustomValidator{validator: validator.New()}\n\n // Initialize the routes.\n initializeRoutes(app)\n\n // Start the server on port 1323.\n app.Logger.Fatal(app.Start(\":1323\"))\n}\n</code></pre>"},{"location":"packages/vendors/esbuild/","title":"ESBuild (TSX)","text":"<pre><code>package main\n\nimport (\n \"fmt\"\n \"regexp\"\n \"strings\"\n\n \"github.com/evanw/esbuild/pkg/api\"\n)\n\nfunc main() {\n // Sample TSX input\n tsxCode := `\nimport \"./style.scss\";\n\n// @GO\n\nconst Layout = (props) =&gt; (\n  &lt;div&gt;\n    &lt;header&gt;Head&lt;/header&gt;\n    &lt;main&gt;{props.children}&lt;/main&gt;\n    &lt;footer&gt;Head&lt;/footer&gt;\n  &lt;/div&gt;\n);\n\nexport default function Button(props) {\n const regexNoReplace = \"export default\"\n  return (\n    &lt;Layout x-html {...props} class={[$NAME, props.class]}&gt;\n      {props.children}\n    &lt;/Layout&gt;\n  );\n}\n\n    `\n\n customizedCode := componentJSX(\"Component\", tsxCode)\n fmt.Println(\"Transformed Code:\")\n fmt.Println(customizedCode)\n}\n\nfunc parseTSX(input string, methodName string, minify bool) string {\n if methodName == \"\" {\n  methodName = \"React.createElement\" // Default value\n }\n\n // Transform TSX to JavaScript\n result := api.Transform(input, api.TransformOptions{\n  Loader: api.LoaderTSX,    // Set the loader to TSX\n  JSX:    api.JSXTransform, // Enable JSX transformation\n  Format: api.FormatESModule,\n })\n\n if len(result.Errors) &gt; 0 {\n  fmt.Println(\"Errors:\", result.Errors)\n  return \"\"\n }\n\n // Replace `/* @__PURE__ */ React.createElement` with a custom function\n transformedCode := string(result.Code)\n customizedCode := strings.ReplaceAll(\n  transformedCode,\n  \"/* @__PURE__ */ React.createElement\",\n  methodName,\n )\n\n if minify {\n  return minifyJS(customizedCode)\n }\n\n return customizedCode\n}\n\n// componentJSX wraps a TSX transformation to create a reusable component function in JavaScript.\n// It generates a JavaScript function named after the provided `name` parameter and applies\n// the transformation and minification logic.\n//\n// Parameters:\n// - name: The name of the JavaScript function to be generated.\n// - input: The TSX input code to be processed.\n//\n// Returns:\n// - A minified JavaScript function string representing the transformed component.\nfunc componentJSX(name string, input string) string {\n // Fix Code Pre-String\n tsxCode := strings.Split(input, \"// @GO\")[1]\n tsxCode = strings.TrimSpace(tsxCode)\n\n // Call the function to replace `export default` only at the start of a line\n tsxCode = replaceRegex(tsxCode, `(?m)^export default`, \"return\")\n // Wrap the transformed code into a named component function\n tsxCode = fmt.Sprintf(\"const %s = (function() { %s })();\", name, tsxCode)\n\n // Transform the input TSX and use \"h\" as the custom JSX pragma\n transformedCode := parseTSX(tsxCode, \"h\", false)\n\n return minifyJS(transformedCode)\n}\n\n// minifyJS reduces the size of the given JavaScript code by applying whitespace,\n// identifier, and syntax minification using esbuild.\n//\n// Parameters:\n// - input: The JavaScript code to be minified.\n//\n// Returns:\n// - A minified JavaScript string, or an empty string if an error occurred.\nfunc minifyJS(input string) string {\n result := api.Transform(input, api.TransformOptions{\n  MinifyWhitespace:  true,\n  MinifyIdentifiers: true,\n  MinifySyntax:      true,\n })\n\n if len(result.Errors) &gt; 0 {\n  fmt.Println(\"Errors:\", result.Errors)\n  return \"\"\n }\n\n return string(result.Code)\n}\n\n// replaceExportDefault replaces occurrences of \"export default\" with the given replacement\n// string, but only if \"export default\" is at the beginning of a line.\n//\n// Parameters:\n// - input: The input string containing code.\n// - replacement: The string to replace \"export default\" with.\n//\n// Returns:\n// - The updated string with replacements applied.\nfunc replaceRegex(input, query string, replacement string) string {\n // Regex pattern to match \"export default\" at the start of a line\n // `(?m)^export default`:\n //   - `(?m)`: Enables multiline mode to allow `^` to match the start of each line.\n //   - `^export default`: Matches \"export default\" at the beginning of a line.\n re := regexp.MustCompile(query)\n\n // Perform the replacement\n return re.ReplaceAllString(input, replacement)\n}\n</code></pre>"},{"location":"packages/vendors/goja/","title":"GOJA - JavaScript - ECMAScript (5.1)","text":"<p>File: <code>tools_js/add.js</code></p> <pre><code>const add = (data) =&gt; a + b;\nconst emit = (val) =&gt; ({ data: val });\n</code></pre> <p>File: <code>main.go</code></p> <pre><code>package main\n\nimport (\n \"fmt\"\n \"log\"\n \"os\"\n\n \"github.com/dop251/goja\"\n)\n\nfunc main() {\n filePath := \"tools_js/add.js\"\n preCode, _ := readFile(filePath)\n runJS(preCode)\n}\n\ntype Dict = map[string]interface{}\n\n// runJS executes the provided JavaScript code and processes the result\nfunc runJS(preCode string) {\n // Create a new Goja VM instance\n vm := goja.New()\n\n // Append additional JavaScript code to the provided code\n script := preCode + `emit(add(1, 2))`\n\n // Execute the script in the Goja VM\n result, is_error := vm.RunString(script)\n if is_error != nil {\n  log.Printf(\"Error executing JavaScript: %v\", is_error)\n  return\n }\n\n // Convert the `goja.Value` to a Go `interface{}`\n goValue := result.Export()\n\n // Convert the result to a map (DictMap) if it's a valid type\n if javascript, ok := goValue.(Dict); ok {\n  // Print the resulting map as JSON (formatted as a map)\n  fmt.Println(\"RETURN:\", javascript[\"data\"])\n } else {\n  log.Println(\"Result is not a valid DictMap.\")\n }\n}\n\n// readFile reads the content of a file and returns it as a string\nfunc readFile(filePath string) (string, error) {\n // Read the file contents into a byte slice\n data, is_error := os.ReadFile(filePath)\n if is_error != nil {\n  return \"\", fmt.Errorf(\"could not read file %s: %v\", filePath, is_error)\n }\n\n // Convert the byte slice to a string and return it\n return string(data), nil\n}\n</code></pre>"},{"location":"packages/vendors/gorm/","title":"GORM - CRUD(S) Operations","text":"<pre><code>package main\n\nimport (\n \"fmt\"\n \"time\"\n\n \"gorm.io/driver/sqlite\"\n \"gorm.io/gorm\"\n _ \"modernc.org/sqlite\" // Import the modernc driver\n)\n\n/*\ntype Model struct {\n ID        uint `gorm:\"primarykey\"`\n CreatedAt time.Time\n UpdatedAt time.Time\n DeletedAt time.Time `gorm:\"index\" default:\"NULL\"`\n}\n*/\n\n// Base model with common fields\ntype Product struct {\n gorm.Model\n Code  string\n Price uint\n}\n\n// Always use UTC\nfunc DateTimeUTC() time.Time {\n return time.Now().UTC()\n}\n\n// Error Wrap\nfunc check(err error) {\n if err != nil {\n  panic(err)\n }\n}\n\nfunc main() {\n // Initialize the database with the \"test.db\" file and auto-migrate models\n db, err := InitDB(\"file:test.db\", &amp;Product{})\n check(err)\n\n // Test Database\n TestDB(db)\n\n}\n\n// InitDB initializes a GORM SQLite database connection\nfunc InitDB(dsn string, models ...interface{}) (*gorm.DB, error) {\n // Open the database connection\n db, err := gorm.Open(sqlite.Dialector{\n  DriverName: \"sqlite\",\n  DSN:        dsn,\n }, &amp;gorm.Config{})\n\n // Check for Errors\n if err != nil {\n  return nil, fmt.Errorf(\"failed to connect to database: %w\", err)\n }\n\n // Migrate the schema\n if len(models) &gt; 0 {\n  if err := db.AutoMigrate(models...); err != nil {\n   return nil, fmt.Errorf(\"failed to migrate database schema: %w\", err)\n  }\n }\n\n return db, nil\n}\n\n// Examples for GORM SQLite Database\n// TestDB demonstrates CRUD operations on the \"products\" table using GORM's db.Table method.\nfunc TestDB(db *gorm.DB) {\n\n // C\n dbCreate((db))\n\n // R\n dbDetail((db))\n\n // U\n time.Sleep(1 * time.Second) // Pause for demonstration purposes\n dbUpdate((db))\n\n // D\n time.Sleep(1 * time.Second) // Pause for demonstration purposes\n dbDelete((db))\n\n // S ~ R\n dbSearch((db))\n\n}\n\n// ----------- Create Operation -----------\nfunc dbCreate(db *gorm.DB) {\n // Insert a new product into the \"products\" table\n db.Table(\"products\").Create(map[string]interface{}{\n  \"code\":       \"F42\",         // Product code\n  \"price\":      100,           // Product price\n  \"created_at\": DateTimeUTC(), // UTC timestamp for created_at\n  \"updated_at\": DateTimeUTC(), // UTC timestamp for updated_at\n })\n\n}\n\n// ----------- Update Operation -----------\nfunc dbUpdate(db *gorm.DB) {\n // Update the product with ID=1\n db.Table(\"products\").\n  Where(\"id IN ?\", []int{1}). // Match product with ID=1\n  Updates(map[string]interface{}{\n   \"code\":       \"D42\",         // Update product code\n   \"price\":      500,           // Update product price\n   \"updated_at\": DateTimeUTC(), // Update timestamp\n  })\n\n}\n\n// ----------- Delete Operation -----------\nfunc dbDelete(db *gorm.DB) {\n // Soft-delete the product by setting the \"deleted_at\" timestamp\n where_ids := db.Where(\"id IN ?\", []int{1})\n db.Table(\"products\").\n  Where(where_ids). // Match product with ID=1\n  Updates(map[string]interface{}{\n   \"deleted_at\": DateTimeUTC(), // Mark as deleted\n  })\n\n}\n\n// ----------- Read Operation -----------\nfunc dbDetail(db *gorm.DB) {\n // Retrieve a product with ID=1, ensuring it's not marked as deleted\n record := map[string]interface{}{}\n db.Table(\"products\").\n  Select(\"*\").                 // Select all fields\n  Where(\"id = ?\", 1).          // Match product with ID=1\n  Where(\"deleted_at IS NULL\"). // Exclude logically deleted records\n  Take(&amp;record)\n\n // Print the retrieved record\n fmt.Println(\"Retrieved Record:\", record)\n}\n\n// ----------- List Operation -----------\nfunc dbSearch(db *gorm.DB) {\n // Retrieve all products that are not marked as deleted\n var results []map[string]interface{}\n db.Table(\"products\").\n  Select(\"*\").                 // Select all fields\n  Where(\"id &gt; ?\", 0).          // Match all products with ID &gt; 0\n  Where(\"deleted_at IS NULL\"). // Exclude logically deleted records\n  Find(&amp;results)\n\n // Print the list of active products\n fmt.Println(\"Active Products:\", results)\n}\n</code></pre>"},{"location":"packages/vendors/minify/","title":"Go HTML Template Rendering with Minification","text":"<p>This Go program demonstrates how to use the <code>html/template</code> package for rendering dynamic HTML pages and minifying the resulting HTML using the <code>github.com/tdewolff/minify</code> package.</p> <p>The program defines an HTML template, renders it with dynamic data, and then minifies the output to reduce its size for better performance in web environments.</p>"},{"location":"packages/vendors/minify/#key-features","title":"Key Features","text":"<ul> <li>HTML Template Rendering: Using Go's <code>html/template</code> package to dynamically insert values into an HTML template.</li> <li>Minification: After rendering the template, the output HTML is minified to remove unnecessary whitespace and optimize the content for the web.</li> </ul>"},{"location":"packages/vendors/minify/#example-template","title":"Example Template","text":""},{"location":"packages/vendors/minify/#template-in-the-go-code","title":"Template (in the Go code):","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;{{.Title}}&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;{{.Heading}}&lt;/h1&gt;\n    &lt;p&gt;{{.Content}}&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>In this template:</p> <ul> <li><code>{{.Title}}</code>, <code>{{.Heading}}</code>, and <code>{{.Content}}</code> are placeholders for dynamic content that will be replaced at runtime.</li> </ul>"},{"location":"packages/vendors/minify/#go-code-example","title":"Go Code Example","text":"<p>Here is the Go code that reads the template, renders it with dynamic data, and minifies the final HTML output.</p> <pre><code>package main\n\nimport (\n \"bytes\"\n \"fmt\"\n \"html/template\"\n \"log\"\n\n \"github.com/tdewolff/minify/v2\"\n \"github.com/tdewolff/minify/v2/html\"\n)\n\n// Dict is a type alias for a map with string keys and values of any type.\ntype Dict = map[string]interface{}\ntype List = []interface{}\n\nfunc main() {\n // Define the template string with placeholders for dynamic content.\n var tmpl = `\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;{{.Title}}&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;{{.Heading}}&lt;/h1&gt;\n    &lt;p&gt;{{.Content}}&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n `\n\n // Data structure holding dynamic values for rendering.\n data := Dict{\n  \"Title\":   \"My Go HTML Template\", // Dynamic value for the title.\n  \"Heading\": \"Welcome to Go Templates!\", // Dynamic value for the heading.\n  \"Content\": template.HTML(\"&lt;strong&gt;This is a dynamic HTML page generated using the html/template package.&lt;/strong&gt;\"), // HTML content.\n }\n\n // Render the HTML template with the provided data.\n render := HTML(tmpl) // Returns a function to render the template.\n htmlContent := render(data) // Generate the HTML by passing the data.\n\n // Minify the rendered HTML content.\n fmt.Println(\"Minified HTML:\")\n fmt.Println(minifyHTML(htmlContent))\n}\n\n// HTML takes a template string and returns a function that renders the template with the given data.\n// This function allows you to reuse the template rendering logic with different data sets.\nfunc HTML(tmpl string) func(data interface{}) string {\n // Parse the template string into a Template object.\n t, err := template.New(\"webpage\").Parse(tmpl)\n if err != nil {\n  // Panic if there's an error parsing the template.\n  panic(err)\n }\n\n // Return a function that renders the template with the provided data.\n return func(data interface{}) string {\n  var buf bytes.Buffer\n  // Execute the template, passing the data to replace placeholders.\n  err := t.Execute(&amp;buf, data)\n  if err != nil {\n   // Panic if there's an error executing the template.\n   panic(err)\n  }\n\n  // Return the generated HTML content as a string.\n  return buf.String()\n }\n}\n\n// minifyHTML takes the rendered HTML string and minifies it by removing unnecessary whitespace.\nfunc minifyHTML(htmlCode string) string {\n // Initialize the minifier.\n m := minify.New()\n\n // Add the minification function for HTML.\n m.AddFunc(\"text/html\", html.Minify)\n\n // Minify the HTML string.\n minifiedHTML, err := m.String(\"text/html\", htmlCode)\n if err != nil {\n  log.Fatal(err) // Log and terminate if there's an error.\n }\n return minifiedHTML\n}\n</code></pre>"},{"location":"packages/vendors/minify/#key-components","title":"Key Components","text":""},{"location":"packages/vendors/minify/#1-html-template-rendering","title":"1. HTML Template Rendering","text":"<p>In the <code>main</code> function, we define a template string that includes placeholders for dynamic data, such as the title, heading, and content. We then use the <code>HTML</code> function to parse and render the template with provided data.</p> <ul> <li>Dynamic Data: The <code>data</code> map contains values for the placeholders in the template (<code>Title</code>, <code>Heading</code>, <code>Content</code>).</li> <li>Rendering: The <code>HTML</code> function compiles the template and generates the final HTML string by executing the template with the given data.</li> </ul>"},{"location":"packages/vendors/minify/#2-minification","title":"2. Minification","text":"<p>After rendering the HTML, the <code>minifyHTML</code> function is called to minimize the output HTML. This step removes unnecessary whitespace and reduces the size of the HTML file, making it more suitable for web usage.</p> <ul> <li>Minifier Setup: The <code>github.com/tdewolff/minify</code> package is used for minification. Specifically, the <code>html.Minify</code> function is applied to minify the HTML.</li> <li>Error Handling: The function uses <code>log.Fatal</code> to terminate the program if an error occurs during minification.</li> </ul>"},{"location":"packages/vendors/minify/#3-output","title":"3. Output","text":"<p>The program outputs the minified HTML to the console. For example:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;My Go HTML Template&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Welcome to Go Templates!&lt;/h1&gt;\n    &lt;p&gt;\n      &lt;strong\n        &gt;This is a dynamic HTML page generated using the html/template\n        package.&lt;/strong\n      &gt;\n    &lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"packages/vendors/minify/#explanation-of-the-code","title":"Explanation of the Code","text":"<ol> <li> <p>Template Parsing:</p> </li> <li> <p>The template string is parsed using <code>template.New(\"webpage\").Parse(tmpl)</code>.</p> </li> <li> <p>If there is an error during parsing, the program panics.</p> </li> <li> <p>Template Execution:</p> </li> <li> <p>The <code>Execute</code> method is called with a buffer (<code>bytes.Buffer</code>) to capture the rendered HTML content.</p> </li> <li> <p>Data is passed to the template to replace placeholders like <code>{{.Title}}</code>, <code>{{.Heading}}</code>, and <code>{{.Content}}</code>.</p> </li> <li> <p>Minification:</p> </li> <li> <p>After rendering the HTML, the <code>minifyHTML</code> function is used to reduce the size of the HTML output by removing unnecessary whitespace and line breaks.</p> </li> <li> <p>Error Handling:</p> </li> <li>Both the template parsing and execution steps include error handling. If any errors occur, the program will panic (terminate).</li> <li>The minification process uses <code>log.Fatal</code> to handle errors gracefully.</li> </ol>"},{"location":"packages/vendors/minify/#conclusion","title":"Conclusion","text":"<p>This Go program demonstrates a simple but effective way to:</p> <ul> <li>Render dynamic HTML content using Go's <code>html/template</code> package.</li> <li>Minify the resulting HTML to reduce its size for better performance on the web.</li> </ul> <p>You can extend this approach by adding more complex templates and handling other content types, such as CSS or JavaScript, with similar minification strategies.</p>"},{"location":"pythonic/any-dict-list/","title":"Any | Dict | List","text":""},{"location":"pythonic/any-dict-list/#python-functions","title":"Python Functions","text":"<pre><code>def method_args(*args): pass\ndef method_kwargs(**kwargs): pass\ndef method_pythonic(*args, **kwargs): pass\n</code></pre>"},{"location":"pythonic/any-dict-list/#go-functions","title":"Go Functions","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// Any is a generic type `alias` for any value.\ntype Any = interface{}\n\n// Dict is a type `alias` for a map with string keys and values of any type.\ntype Dict = map[string]interface{}\n\n// List is a type `alias` for a slice of values of any type.\ntype List = []interface{}\n\n// methodArgs simulates Python's *args by accepting a variadic list of arguments.\nfunc methodArgs(args ...Any) {\n fmt.Println(\"Handling *args:\")\n for i, arg := range args {\n  fmt.Printf(\"  Arg %d: %v\\n\", i, arg)\n }\n}\n\n// methodKwargs simulates Python's **kwargs by accepting a dictionary of key-value pairs.\nfunc methodKwargs(kwargs Dict) {\n fmt.Println(\"Handling **kwargs:\")\n for key, value := range kwargs {\n  fmt.Printf(\"  %s: %v\\n\", key, value)\n }\n}\n\n// methodPythonic combines *args and **kwargs functionality, accepting both positional and keyword arguments.\nfunc methodPythonic(args List, kwargs Dict) {\n // Handle *args\n fmt.Println(\"Handling *args:\")\n for i, arg := range args {\n  fmt.Printf(\"  Arg %d: %v\\n\", i, arg)\n }\n\n // Handle **kwargs\n fmt.Println(\"Handling **kwargs:\")\n for key, value := range kwargs {\n  fmt.Printf(\"  %s: %v\\n\", key, value)\n }\n}\n\nfunc main() {\n // Example usage of methodArgs\n methodArgs(1, \"hello\", true, 42.5)\n\n // Example usage of methodKwargs\n methodKwargs(Dict{\n  \"name\":  \"Alice\",\n  \"age\":   30,\n  \"admin\": true,\n })\n\n // Example usage of methodPythonic\n methodPythonic(\n  List{10, \"example\", false},\n  Dict{\n   \"status\":  \"active\",\n   \"message\": \"success\",\n  },\n )\n}\n</code></pre>"},{"location":"pythonic/data-types/","title":"Python | JavaScript | SQL | Go | JSON | GraphQL","text":"Field/Type Python JavaScript SQL Go JSON GraphQL Integer <code>int</code> <code>Number</code> <code>INTEGER</code> <code>int</code>, <code>int32</code>, <code>int64</code> <code>number</code> <code>Int</code> Float <code>float</code> <code>Number</code> <code>FLOAT</code>, <code>DOUBLE</code> <code>float32</code>, <code>float64</code> <code>number</code> <code>Float</code> String <code>str</code> <code>String</code> <code>VARCHAR</code>, <code>TEXT</code> <code>string</code> <code>string</code> <code>String</code> Boolean <code>bool</code> <code>Boolean</code> <code>BOOLEAN</code> <code>bool</code> <code>true</code>, <code>false</code> <code>Boolean</code> Array/List <code>list</code>, <code>tuple</code> <code>Array</code> <code>ARRAY</code> <code>[]type</code> (slice) <code>[]type</code> (array) <code>[Type]</code> Object/Dict <code>dict</code> <code>Object</code> <code>JSON</code>, <code>TEXT</code> (via serialization) <code>map[string]Type</code> (map) <code>object</code> <code>Object</code> Null <code>None</code> <code>null</code> <code>NULL</code> <code>nil</code> <code>null</code> <code>null</code> Date/Time <code>datetime</code>, <code>date</code> <code>Date</code>, <code>DateTime</code> <code>DATE</code>, <code>TIMESTAMP</code> <code>time.Time</code> <code>string</code> (ISO 8601) <code>DateTime</code> UUID <code>uuid.UUID</code> <code>UUID</code> (via library) <code>UUID</code> <code>uuid.UUID</code> <code>string</code> (UUID string) <code>ID</code> (commonly used for unique identifiers) Binary <code>bytes</code> <code>Buffer</code> <code>BLOB</code>, <code>BYTEA</code> <code>[]byte</code> <code>string</code> (Base64) (No specific type, usually as string) Float or Int <code>Union[int, float]</code> <code>Number</code> <code>INTEGER</code> or <code>FLOAT</code> <code>float64</code> or <code>int</code> <code>number</code> <code>Float</code> (can be int or float) Any <code>Any</code> (<code>object</code>, <code>Union</code>) <code>any</code> (via <code>any</code> or <code>Object</code>) (depends on DB type) <code>interface{}</code> <code>any</code> (using <code>interface{}</code> for complex or unknown) <code>Any</code> (usually as <code>Scalar</code> type) Enum <code>Enum</code> (via <code>enum</code> module) Enum (via objects) <code>ENUM</code> <code>enum</code> (custom or string constants) <code>string</code> (set of allowed values) <code>enum</code> (with specific allowed values)"},{"location":"pythonic/data-types/#explanations","title":"Explanations","text":"<ul> <li>Python: Commonly uses <code>int</code>, <code>str</code>, <code>float</code>, <code>bool</code>, and <code>dict</code> for data types. For JSON-like structures, <code>dict</code> is used, and <code>list</code> or <code>tuple</code> is used for arrays.</li> <li>JavaScript: Primarily uses <code>Number</code> for integers and floats, <code>String</code> for strings, and <code>Object</code> for JSON objects. JavaScript uses <code>Array</code> for lists.</li> <li>SQL: SQL has its own standard types like <code>INTEGER</code>, <code>VARCHAR</code>, and <code>BOOLEAN</code>. For date/time, SQL uses <code>DATE</code>, <code>TIME</code>, and <code>TIMESTAMP</code>.</li> <li>Go: Go uses <code>int</code>, <code>float64</code>, <code>string</code>, <code>bool</code>, and <code>map</code> for maps. Arrays in Go are slices (<code>[]Type</code>). Go does not directly have an equivalent for <code>None</code> but uses <code>nil</code> for uninitialized pointers or slices.</li> <li>JSON: In JSON, types are dynamic and loosely typed, such as <code>number</code> (for both integers and floats), <code>string</code>, <code>boolean</code>, and <code>object</code> (equivalent to a JSON object). Arrays in JSON are represented as a list of items.</li> <li>GraphQL: GraphQL uses types like <code>Int</code>, <code>Float</code>, <code>String</code>, <code>Boolean</code>, and <code>ID</code> (usually for unique identifiers). It allows complex types like <code>Object</code> and <code>Enum</code> to define allowable values or structures. The <code>Any</code> type is often represented as <code>Scalar</code> in GraphQL.</li> </ul>"},{"location":"pythonic/data-types/#special-notes","title":"Special Notes","text":"<ul> <li>UUIDs: Both Python and Go have specialized libraries to handle UUIDs. In JSON and GraphQL, UUIDs are typically serialized as strings.</li> <li>Date/Time: All the systems handle date and time, but the format can differ. Most systems (Go, Python, GraphQL, JSON) use ISO 8601 string representations for date and time.</li> <li>Null Values: The concept of <code>null</code> is the same across most systems, though in Go, it\u2019s represented as <code>nil</code> for references. SQL uses <code>NULL</code>, and GraphQL uses <code>null</code>.</li> </ul>"},{"location":"pythonic/decorators/","title":"Decorators","text":"<p>Go doesn't have decorators or wrappers in the same way Python does, but you can achieve similar functionality using higher-order functions (functions that take other functions as arguments or return them), closures, and interfaces.</p>"},{"location":"pythonic/decorators/#examples","title":"Examples","text":""},{"location":"pythonic/decorators/#achieving-decorator-like-behavior-in-go","title":"Achieving Decorator-like Behavior in Go","text":"<ol> <li> <p>Higher-order functions: In Go, you can pass functions as arguments to other functions, or return them. This lets you wrap or modify the behavior of a function.</p> </li> <li> <p>Closures: You can create closures (functions that \"remember\" the environment in which they were created) that allow for wrapping functionality and preserving state.</p> </li> </ol>"},{"location":"pythonic/decorators/#example-1-wrapping-functions-like-a-decorator","title":"Example 1: Wrapping Functions (like a decorator)","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// A function that takes another function and adds additional behavior (like a decorator)\nfunc logExecution(fn func(string) string) func(string) string {\n    return func(input string) string {\n        fmt.Println(\"Before calling the function\")\n        result := fn(input)  // Call the original function\n        fmt.Println(\"After calling the function\")\n        return result\n    }\n}\n\n// A simple function to be decorated\nfunc sayHello(name string) string {\n    return \"Hello, \" + name\n}\n\nfunc main() {\n    // Wrap sayHello with the logExecution \"decorator\"\n    decorated := logExecution(sayHello)\n\n    // Call the decorated function\n    result := decorated(\"Alice\")\n    fmt.Println(result)  // Outputs: \"Hello, Alice\"\n}\n</code></pre>"},{"location":"pythonic/decorators/#explanation-1","title":"Explanation 1","text":"<ul> <li><code>logExecution</code> is a higher-order function that takes another function <code>fn</code> as an argument and returns a new function that wraps <code>fn</code>. This is like a decorator in Python.</li> <li>The returned function has additional logic (in this case, logging before and after the function call) around the original function.</li> </ul>"},{"location":"pythonic/decorators/#example-2-wrapping-methods-with-closures","title":"Example 2: Wrapping Methods with Closures","text":"<p>In Go, closures can also be used to encapsulate behavior around methods.</p> <pre><code>package main\n\nimport \"fmt\"\n\n// A function that takes a method and wraps it with additional behavior\nfunc addLogging(fn func()) func() {\n    return func() {\n        fmt.Println(\"Before function call\")\n        fn()  // Original function call\n        fmt.Println(\"After function call\")\n    }\n}\n\nfunc greet() {\n    fmt.Println(\"Hello, World!\")\n}\n\nfunc main() {\n    // Wrap greet with addLogging\n    loggedGreet := addLogging(greet)\n    loggedGreet()  // Outputs logs before and after greet\n}\n</code></pre>"},{"location":"pythonic/decorators/#example-3-wrapping-methods-with-interfaces","title":"Example 3: Wrapping Methods with Interfaces","text":"<p>You can also achieve decorator-like functionality with interfaces in Go, especially when working with methods in structs.</p> <pre><code>package main\n\nimport \"fmt\"\n\n// Define an interface for the behavior we want to decorate\ntype Greeter interface {\n    Greet() string\n}\n\n// A basic struct that implements the Greeter interface\ntype Person struct {\n    Name string\n}\n\nfunc (p Person) Greet() string {\n    return \"Hello, \" + p.Name\n}\n\n// A decorator that wraps a Greeter and modifies its behavior\ntype GreeterWithLog struct {\n    Greeter\n}\n\nfunc (g GreeterWithLog) Greet() string {\n    fmt.Println(\"Before greeting\")\n    result := g.Greeter.Greet()  // Call the original Greet method\n    fmt.Println(\"After greeting\")\n    return result\n}\n\nfunc main() {\n    person := Person{Name: \"Alice\"}\n    greeter := GreeterWithLog{Greeter: person}\n\n    fmt.Println(greeter.Greet())  // Outputs log and the greeting\n}\n</code></pre>"},{"location":"pythonic/decorators/#explanation-3","title":"Explanation 3","text":"<ul> <li>Interface: We define the <code>Greeter</code> interface and then implement it with the <code>Person</code> struct.</li> <li>Decorator: The <code>GreeterWithLog</code> struct \"wraps\" a <code>Greeter</code> and modifies its behavior. The method <code>Greet()</code> of <code>GreeterWithLog</code> adds additional behavior before and after calling the original <code>Greet()</code> method.</li> </ul>"},{"location":"pythonic/decorators/#differences-from-python-decorators","title":"Differences from Python Decorators","text":"<ul> <li>Python decorators: Python decorators are syntactic sugar that allows wrapping a function or method in a cleaner way using the <code>@decorator</code> syntax.</li> <li>Go Wrappers: In Go, decorators can be implemented using higher-order functions, closures, or interfaces, but the syntax and approach differ from Python.</li> </ul>"},{"location":"pythonic/decorators/#summary","title":"Summary","text":"<p>While Go doesn't have Python-style decorators, you can still achieve similar functionality through higher-order functions, closures, and interfaces, which are powerful tools for wrapping and modifying behavior in Go.</p>"},{"location":"pythonic/kwargs/","title":"Key-Value Arguments","text":"<p>Go does not have an exact equivalent to Python's <code>**kwargs</code>, but you can achieve similar functionality using one of the following approaches:</p>"},{"location":"pythonic/kwargs/#dict-annotation","title":"Dict annotation","text":"<pre><code>type Dict = map[string]interface{}\n</code></pre>"},{"location":"pythonic/kwargs/#kwargs-examples","title":"Kwargs Examples","text":""},{"location":"pythonic/kwargs/#1-using-variadic-arguments-interface","title":"1. Using Variadic Arguments (<code>...interface{}</code>)","text":"<p>You can use Go's variadic arguments to pass an arbitrary number of arguments. This is the closest equivalent to Python's <code>*args</code> or <code>**kwargs</code> but does not enforce named arguments.</p> <pre><code>package main\n\nimport \"fmt\"\n\n// Function that accepts variadic arguments\nfunc printValues(key string, values ...interface{}) {\n    fmt.Printf(\"Key: %s, Values: %v\\n\", key, values)\n}\n\nfunc main() {\n    printValues(\"example\", 1, \"text\", true, 3.14)\n}\n</code></pre> <p>Explanation:</p> <ul> <li><code>values ...interface{}</code> allows you to pass any number of arguments of any type.</li> <li>You must handle the data manually within the function.</li> </ul>"},{"location":"pythonic/kwargs/#2-using-maps-for-named-arguments","title":"2. Using Maps for Named Arguments","text":"<p>To mimic <code>**kwargs</code>, you can pass a map of key-value pairs.</p> <pre><code>package main\n\nimport \"fmt\"\n\ntype Dict = map[string]interface{}\n\n// Function that accepts a map for named arguments\nfunc process(kwargs Dict) {\n    for key, value := range kwargs {\n        fmt.Printf(\"Key: %s, Value: %v\\n\", key, value)\n    }\n}\n\nfunc main() {\n    kwargs := Dict{\n        \"name\":  \"Alice\",\n        \"age\":   30,\n        \"admin\": true,\n    }\n\n    process(kwargs)\n}\n</code></pre> <p>Explanation:</p> <ul> <li>A <code>map[string]interface{}</code> acts as a dictionary for named arguments.</li> <li>This approach makes it easier to manage key-value pairs.</li> </ul>"},{"location":"pythonic/kwargs/#3-using-structs-for-typed-named-arguments","title":"3. Using Structs for Typed Named Arguments","text":"<p>If the keys and their types are predefined, you can use a struct. This provides compile-time type safety.</p> <pre><code>package main\n\nimport \"fmt\"\n\n// Struct for named arguments\ntype Options struct {\n    Name  string\n    Age   int\n    Admin bool\n}\n\n// Function that accepts a struct\nfunc greet(opts Options) {\n    fmt.Printf(\"Hello, %s! Age: %d, Admin: %v\\n\", opts.Name, opts.Age, opts.Admin)\n}\n\nfunc main() {\n    opts := Options{Name: \"Alice\", Age: 30, Admin: true}\n    greet(opts)\n}\n</code></pre> <p>Explanation:</p> <ul> <li>A <code>struct</code> groups predefined keys with their respective types.</li> <li>This is the most idiomatic way in Go when you know the expected arguments.</li> </ul>"},{"location":"pythonic/kwargs/#comparison-with-python-kwargs","title":"Comparison with Python <code>**kwargs</code>","text":"Feature Python <code>**kwargs</code> Go Alternatives Arbitrary arguments <code>**kwargs</code> <code>...interface{}</code> Named arguments <code>**kwargs</code> (dict-like) <code>map[string]interface{}</code> Type-safe named args Not directly possible <code>struct</code> with predefined fields"},{"location":"pythonic/kwargs/#summary","title":"Summary","text":"<ul> <li>Use <code>...interface{}</code> for flexibility but without named arguments.</li> <li>Use <code>map[string]interface{}</code> for dynamic named arguments (closest to <code>**kwargs</code>).</li> <li>Use a <code>struct</code> for type safety when arguments are known ahead of time.</li> </ul> <p>Each approach has its use case depending on the level of flexibility or type safety you need!</p>"},{"location":"pythonic/kwargs/#kwargs-and-args","title":"Kwargs and Args","text":""},{"location":"pythonic/kwargs/#using-a-slice-and-a-map","title":"Using a Slice and a Map","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// Method that mimics *args and **kwargs, returns a reusable function\nfunc method(args []string) func(kwargs map[string]interface{}) map[string]interface{} {\n    return func(kwargs map[string]interface{}) map[string]interface{} {\n        result := make(map[string]interface{})\n\n        // Iterate over args and populate result with corresponding kwargs\n        for _, key := range args {\n            if value, exists := kwargs[key]; exists {\n                result[key] = value\n            }\n        }\n\n        return result\n    }\n}\n\nfunc main() {\n // Example usage\n args := []string{\"name\", \"age\"}\n kwargs := map[string]interface{}{\n  \"name\": \"John Doe\",\n  \"age\":  30,\n  \"city\": \"New York\",\n }\n\n result := method(args, kwargs)\n fmt.Println(result) // Output: map[name:John Doe age:30]\n}\n</code></pre>"},{"location":"pythonic/operators/","title":"Operators","text":""},{"location":"pythonic/operators/#python","title":"Python","text":""},{"location":"pythonic/operators/#comparison-operators","title":"Comparison Operators","text":"<ul> <li><code>lt</code> (Less Than <code>&lt;</code>)</li> <li><code>lte</code> (Less Than or Equal To <code>&lt;=</code>)</li> <li><code>gt</code> (Greater Than <code>&gt;</code>)</li> <li><code>gte</code> (Greater Than or Equal To <code>&gt;=</code>)</li> <li><code>eq</code> (Equal <code>==</code>)</li> <li><code>ne</code> (Not Equal <code>!=</code>)</li> </ul>"},{"location":"pythonic/operators/#logical-operators","title":"Logical Operators","text":"<ul> <li><code>and</code> (Logical AND <code>and</code>)</li> <li><code>or</code> (Logical OR <code>or</code>)</li> <li><code>not</code> (Logical NOT <code>not</code>)</li> </ul>"},{"location":"pythonic/operators/#membership-and-identity-operators","title":"Membership and Identity Operators","text":"<ul> <li><code>in</code> (Membership <code>in</code>)</li> <li><code>is</code> (Identity <code>is</code>)</li> </ul>"},{"location":"pythonic/operators/#special-operators-for-frameworks-or-advanced-use","title":"Special Operators (for frameworks or advanced use)","text":"<ul> <li><code>contains</code> (Check containment)</li> <li><code>startswith</code> (String starts with)</li> <li><code>endswith</code> (String ends with)</li> </ul>"},{"location":"pythonic/operators/#sql","title":"SQL","text":""},{"location":"pythonic/operators/#comparison-operators_1","title":"Comparison Operators","text":"<ul> <li><code>=</code> : Equal</li> <li><code>&lt;&gt;</code> or <code>!=</code> : Not Equal</li> <li><code>&lt;</code> : Less Than</li> <li><code>&lt;=</code> : Less Than or Equal To</li> <li><code>&gt;</code> : Greater Than</li> <li><code>&gt;=</code> : Greater Than or Equal To</li> </ul>"},{"location":"pythonic/operators/#logical-operators_1","title":"Logical Operators","text":"<ul> <li><code>AND</code> : Logical AND</li> <li><code>OR</code> : Logical OR</li> <li><code>NOT</code> : Logical NOT</li> </ul>"},{"location":"pythonic/operators/#arithmetic-operators","title":"Arithmetic Operators","text":"<ul> <li><code>+</code> : Addition</li> <li><code>-</code> : Subtraction</li> <li><code>*</code> : Multiplication</li> <li><code>/</code> : Division</li> <li><code>%</code> : Modulus (used for remainders, supported in some SQL dialects)</li> </ul>"},{"location":"pythonic/operators/#string-operators","title":"String Operators","text":"<ul> <li><code>||</code> : Concatenate strings (SQL standard, used in PostgreSQL)</li> <li><code>+</code> : Concatenate strings (used in SQL Server)</li> <li><code>CONCAT</code> : Concatenate strings (MySQL, some others)</li> </ul>"},{"location":"pythonic/operators/#pattern-matching-operators","title":"Pattern Matching Operators","text":"<ul> <li><code>LIKE</code> : Search for a pattern (e.g., <code>WHERE column LIKE 'A%'</code>)</li> <li><code>NOT LIKE</code> : Search for values that don't match a pattern</li> <li><code>ILIKE</code> : Case-insensitive <code>LIKE</code> (PostgreSQL)</li> </ul>"},{"location":"pythonic/operators/#set-operators","title":"Set Operators","text":"<ul> <li><code>IN</code> : Match a value in a list (e.g., <code>WHERE column IN ('A', 'B')</code>)</li> <li><code>NOT IN</code> : Match a value not in a list</li> <li><code>EXISTS</code> : Check if a subquery returns rows</li> <li><code>NOT EXISTS</code> : Check if a subquery returns no rows</li> </ul>"},{"location":"pythonic/operators/#null-check-operators","title":"NULL Check Operators","text":"<ul> <li><code>IS NULL</code> : Check if a value is <code>NULL</code></li> <li><code>IS NOT NULL</code> : Check if a value is not <code>NULL</code></li> </ul>"},{"location":"pythonic/operators/#comparison-with-subqueries","title":"Comparison with Subqueries","text":"<ul> <li><code>ANY</code> : Compare to any value returned by a subquery (e.g., <code>WHERE column &gt; ANY (subquery)</code>)</li> <li><code>ALL</code> : Compare to all values returned by a subquery (e.g., <code>WHERE column &gt; ALL (subquery)</code>)</li> </ul>"},{"location":"pythonic/operators/#joins-and-relationships","title":"Joins and Relationships","text":"<ul> <li><code>=</code> : Equality in join conditions</li> <li><code>ON</code> : Specifies join conditions</li> <li><code>USING</code> : Specifies join columns in certain SQL dialects</li> </ul>"},{"location":"pythonic/operators/#specialized-operators","title":"Specialized Operators","text":"<ul> <li><code>BETWEEN</code> : Specify a range (inclusive, e.g., <code>WHERE column BETWEEN 10 AND 20</code>)</li> <li><code>NOT BETWEEN</code> : Specify a range exclusion</li> <li><code>DISTINCT</code> : Eliminate duplicates (used with <code>SELECT</code>)</li> <li><code>UNION</code> : Combine results from multiple queries, removing duplicates</li> <li><code>UNION ALL</code> : Combine results from multiple queries, including duplicates</li> <li><code>INTERSECT</code> : Return rows common to multiple queries</li> <li><code>EXCEPT</code> or <code>MINUS</code> : Return rows from one query not in another (depends on SQL dialect)</li> </ul>"},{"location":"pythonic/operators/#full-text-search-operators","title":"Full-Text Search Operators","text":"<p>(Supported in certain SQL dialects)</p> <ul> <li><code>MATCH</code> : Full-text search (e.g., <code>MATCH(column) AGAINST ('text')</code> in MySQL)</li> <li><code>CONTAINS</code> : Full-text search in SQL Server</li> <li><code>TO_TSVECTOR</code> and <code>TO_TSQUERY</code> : Full-text search in PostgreSQL</li> </ul>"},{"location":"pythonic/operators/#bitwise-operators","title":"Bitwise Operators","text":"<p>(Supported in some SQL dialects)</p> <ul> <li><code>&amp;</code> : Bitwise AND</li> <li><code>|</code> : Bitwise OR</li> <li><code>^</code> : Bitwise XOR</li> <li><code>~</code> : Bitwise NOT</li> <li><code>&lt;&lt;</code> : Left shift</li> <li><code>&gt;&gt;</code> : Right shift</li> </ul>"},{"location":"pythonic/operators/#aggregate-operators","title":"Aggregate Operators","text":"<p>(Used with aggregate functions)</p> <ul> <li><code>GROUP BY</code> : Group rows</li> <li><code>HAVING</code> : Filter grouped rows</li> </ul>"},{"location":"pythonic/strings/","title":"Pythonic String Search","text":"<pre><code>package main\n\nimport (\n \"fmt\"\n \"strings\"\n)\n\nfunc main() {\n text := \"Hello, World!\"\n prefix := \"Hello\"\n suffix := \"World!\"\n substring := \"lo, Wo\"\n\n // StartsWith\n if strings.HasPrefix(text, prefix) {\n  fmt.Printf(\"The text starts with '%s'\\n\", prefix)\n }\n\n // EndsWith\n if strings.HasSuffix(text, suffix) {\n  fmt.Printf(\"The text ends with '%s'\\n\", suffix)\n }\n\n // Contains\n if strings.Contains(text, substring) {\n  fmt.Printf(\"The text contains '%s'\\n\", substring)\n }\n\n // Regex\n startsWithPattern := `^Hello`\n startsWithRegex := regexp.MustCompile(startsWithPattern)\n if startsWithRegex.MatchString(text) {\n  fmt.Printf(\"The text starts with 'Hello'\\n\")\n }\n}\n</code></pre>"}]}